==============
URL 分发器
==============

简洁、优雅的 URL 模式在高质量的 Web 应用中是一个非常重要的细节。Django 允许你任意设计你的 URL，不受框架束缚。

不要求有 ``.php`` 或 ``.cgi``，更不会要求类似 ``0,2097,1-1-1928,00`` 这样无意义的东西。

参见 World Wide Web 的发明者 Tim Berners-Lee 的 `Cool URIs don't change`_，里面有关于为什么 URL 应该保持整洁和有意义的卓越的论证。

.. _Cool URIs don't change: http://www.w3.org/Provider/Style/URI

概述
========

为了给一个应用设计 URL，你需要创建一个 Python 模块，通常称为 **URLconf** （URL configuration）。这个模块是纯粹的 Python 代码，包含 URL 模式（简单的正则表达式）到 Python 函数（你的视图）的简单映射。

映射可短可长，随便你。它可以引用其它的映射。而且，因为它是纯粹的 Python 代码，它可以动态构造。

Django 还提供根据当前语言翻译 URL 的一种方法。更多信息参见 :ref:`国际化文档
<url-internationalization>`。

.. _how-django-processes-a-request:

Django 如何处理一个请求
==============================

当一个用户请求 Django 站点的一个页面，下面是 Django 系统决定执行哪个 Python 代码使用的算法：

1. Django 决定要使用的根 URLconf 模块。通常，这个值就是 :setting:`ROOT_URLCONF` 的设置，但是如果进来的 ``HttpRequest`` 对象具有一个 :attr:`~django.http.HttpRequest.urlconf` 属性（通过中间件设置），则使用这个值来替换 :setting:`ROOT_URLCONF` 设置。

2. Django 加载该 Python 模块并寻找可用的 ``urlpatterns``。它是 :func:`django.conf.urls.url` 实例的一个 Python 列表。

3. Django 依次匹配每个 URL 模式，在与请求的 URL 匹配的第一个模式停下来。

4. 一旦其中的一个正则表达式匹配上，Django 将导入并调用给出的视图，它是一个简单的 Python 函数（或者一个 :doc:`基于类的视图
   </topics/class-based-views/index>`）。视图将获得如下参数：

   * 一个 :class:`~django.http.HttpRequest` 实例。
   * 如果匹配的正则表达式没有返回命名的组，那么正则表达式匹配的内容将作为位置参数提供给视图。
   * 关键字参数由正则表达式匹配的命名组组成，但是可以被 ``kwargs`` 的可选参数 :func:`django.conf.urls.url` 覆盖。

5. 如果没有匹配到正则表达式，或者如果过程中抛出一个异常，Django 将调用一个适当的错误处理视图。请参见下面的 `错误处理`_。

例子
=======

下面是一个简单的 URLconf::

    from django.conf.urls import url

    from . import views

    urlpatterns = [
        url(r'^articles/2003/$', views.special_case_2003),
        url(r'^articles/([0-9]{4})/$', views.year_archive),
        url(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive),
        url(r'^articles/([0-9]{4})/([0-9]{2})/([0-9]+)/$', views.article_detail),
    ]

注：

* 若要从 URL 中捕获一个值，只需要在它周围放置一对圆括号。

* 不需要添加一个前导的反斜杠，因为每个URL 都有。例如，应该是 ``^articles`` 而不是 ``^/articles``。

* 每个正则表达式前面的 ``'r'`` 是可选的但是建议加上。它告诉Python 这个字符串是“原始的” —— 字符串中任何字符都不应该转义。参见 `Dive Into Python 中的解释`_。

一些请求的例子：

* ``/articles/2005/03/`` 请求将匹配列表中的第三个模式。Django 将调用函数 ``views.month_archive(request, '2005', '03')``。

* ``/articles/2005/3/`` 不匹配任何 URL 模式，因为列表中的第三个模式要求月份应该是两个数字。

* ``/articles/2003/`` 将匹配列表中的第一个模式不是第二个，因为模式按顺序匹配，第一个会首先测试是否匹配。请像这样自由插入一些特殊的情况来探测匹配的次序。在这里，Django 将调用函数 ``views.special_case_2003(request)``。

* ``/articles/2003`` 不匹配任何一个模式，因为每个模式要求 URL 以一个反斜线结尾。

* ``/articles/2003/03/03/`` 将匹配最后一个模式。Django 将调用函数 ``views.article_detail(request, '2003', '03', '03')``。

.. _Dive Into Python 中的解释: http://www.diveintopython.net/regular_expressions/street_addresses.html#re.matching.2.3

命名组
============

上面的示例使用简单的、*没有命名* 的正则表达式组（通过圆括号）来捕获URL 中的值并以 *位置* 参数传递给视图。在更高级的用法中，可以使用 *命名* 的正则表达式组来捕获 URL 中的值并以 *关键字* 参数传递给视图。

在 Python 正则表达式中，命名正则表达式组的语法是 ``(?P<name>pattern)``，其中 ``name`` 是组的名称，``pattern`` 是要匹配的模式。

下面是以上 URLconf 使用命名组的重写::

    from django.conf.urls import url

    from . import views

    urlpatterns = [
        url(r'^articles/2003/$', views.special_case_2003),
        url(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
        url(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$', views.month_archive),
        url(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<day>[0-9]{2})/$', views.article_detail),
    ]

这个实现与前面的示例完全相同，只有一个细微的差别：捕获的值作为关键字参数而不是位置参数传递给视图函数。例如：

* ``/articles/2005/03/`` 请求将调用 ``views.month_archive(request, year='2005', month='03')`` 函数，而不是 ``views.month_archive(request, '2005', '03')``。

* ``/articles/2003/03/03/`` 请求将调用函数 ``views.article_detail(request, year='2003', month='03', day='03')``。

在实际应用中，这意味你的 URLconf 会更加明晰且不容易产生参数顺序问题的错误 —— 你可以在你的视图函数定义中重新安排参数的顺序。当然，这些好处是以简洁为代价；有些开发人员认为命名组语法丑陋而繁琐。

匹配/分组算法
-------------------------------

下面是 URLconf 解析器使用的算法，针对正则表达式中的命名组和非命名组：

1. 如果有命名参数，则使用这些命名参数，忽略非命名参数。

2. 否则，它将以位置参数传递所有的非命名参数。

根据 `传递额外的选项给视图函数`_ （下文），这两种情况下，多余的关键字参数也将传递给视图。

URLconf 在什么上查找
=================================

URLconf 在请求的 URL 上查找，将它当做一个普通的 Python 字符串。不包括 GET 和 POST 参数以及域名。

例如，``https://www.example.com/myapp/`` 请求中，URLconf 将查找 ``myapp/``。

在 ``https://www.example.com/myapp/?page=3`` 请求中，URLconf 仍将查找 ``myapp/``。

URLconf 不检查请求的方法。换句话讲，所有的请求方法 —— 同一个 URL 的 ``POST``、``GET``、``HEAD`` 等等 —— 都将路由到相同的函数。

捕获的参数永远是字符串
=====================================

每个捕获的参数都作为一个普通的 Python 字符串传递给视图，无论正则表达式使用的是什么匹配方式。例如，下面这行 URLconf 中::

    url(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),

...``views.year_archive()`` 的 ``year`` 参数将是一个字符串，即使 ``[0-9]{4}`` 值匹配整数字符串。

指定视图参数的默认值
======================================

有一个方便的小技巧是指定视图参数的默认值。 下面是一个 URLconf 和视图的示例::

    # URLconf
    from django.conf.urls import url

    from . import views

    urlpatterns = [
        url(r'^blog/$', views.page),
        url(r'^blog/page(?P<num>[0-9]+)/$', views.page),
    ]

    # View (in blog/views.py)
    def page(request, num="1"):
        # Output the appropriate page of blog entries, according to num.
        ...

在上面的例子中，两个 URL 模式指向同一个视图 ``views.page`` —— 但是第一个模式不会从 URL 中捕获任何值。如果第一个模式匹配，``page()`` 函数将使用 ``num`` 参数的默认值 ``"1"``。如果第二个模式匹配，``page()`` 将使用正则表达式捕获的 ``num`` 值。

性能
===========

``urlpatterns`` 中的每个正则表达式在第一次访问它们时被编译。这使得系统相当快。

`urlpatterns`` 变量的语法
======================================

``urlpatterns`` 应该是 :func:`~django.conf.urls.url` 实例的一个 Python 列表。

错误处理
==============

当 Django 找不到一个匹配请求的 URL 的正则表达式时，或者当抛出一个异常时，Django 将调用一个错误处理视图。

这些情况发生时使用的视图通过四个变量指定。它们的默认值应该满足大部分项目，但是通过赋值给它们以进一步的自定义也是可以的。

完整的细节请参见 :ref:`自定义错误视图 <customizing-error-views>`。

这些值可以在你的根 URLconf 中设置。在其它 URLconf 中设置这些变量将不会生效果。

它们的值必须是可调用的或者是表示视图的 Python 完整导入路径的字符串，可以方便地调用它们来处理错误情况。

这些值是：

* ``handler400`` —— 参见 :data:`django.conf.urls.handler400`。
* ``handler403`` —— 参见 :data:`django.conf.urls.handler403`。
* ``handler404`` —— 参见 :data:`django.conf.urls.handler404`。
* ``handler500`` —— 参见 :data:`django.conf.urls.handler500`。

.. _including-other-urlconfs:

包含其它的 URLconf
========================

在任何时候，你的 ``urlpatterns`` 都可以“包含”其它 URLconf 模块。这实际上将一部分 URL 放置与其它 URL “下面”。

例如，下面是 `Django 网站`_ 自己的 URLconf 中一个片段。它包含许多其它 URLconf::

    from django.conf.urls import include, url

    urlpatterns = [
        # ... snip ...
        url(r'^community/', include('django_website.aggregator.urls')),
        url(r'^contact/', include('django_website.contact.urls')),
        # ... snip ...
    ]

注意，这个例子中的正则表达式没有包含 ``$`` （字符串结束匹配符），但是包含一个末尾的反斜杠。每当 Django 遇到 ``include()`` （:func:`django.conf.urls.include()`）时，它会去掉 URL 中匹配的部分并将剩下的字符串发送给包含的 URLconf 做进一步处理。

另外一种包含其它URL 模式的方式是使用一个 :func:`~django.conf.urls.url` 实例的列表。例如，请看下面的 URLconf::

    from django.conf.urls import include, url

    from apps.main import views as main_views
    from credit import views as credit_views

    extra_patterns = [
        url(r'^reports/$', credit_views.report),
        url(r'^reports/(?P<id>[0-9]+)/$', credit_views.report),
        url(r'^charge/$', credit_views.charge),
    ]

    urlpatterns = [
        url(r'^$', main_views.homepage),
        url(r'^help/', include('apps.help.urls')),
        url(r'^credit/', include(extra_patterns)),
    ]

在这个例子中，``/credit/reports/`` URL 将被 ``credit_views.report()`` 这个 Django 视图处理。

这种方法可以用来去除 URLconf 中的冗余，其中某个模式前缀被重复使用。例如，考虑这个 URLconf::

    from django.conf.urls import url
    from . import views

    urlpatterns = [
        url(r'^(?P<page_slug>[\w-]+)-(?P<page_id>\w+)/history/$', views.history),
        url(r'^(?P<page_slug>[\w-]+)-(?P<page_id>\w+)/edit/$', views.edit),
        url(r'^(?P<page_slug>[\w-]+)-(?P<page_id>\w+)/discuss/$', views.discuss),
        url(r'^(?P<page_slug>[\w-]+)-(?P<page_id>\w+)/permissions/$', views.permissions),
    ]

我们可以改进它，通过只声明共同的路径前缀一次并将后面的部分分组::

    from django.conf.urls import include, url
    from . import views

    urlpatterns = [
        url(r'^(?P<page_slug>[\w-]+)-(?P<page_id>\w+)/', include([
            url(r'^history/$', views.history),
            url(r'^edit/$', views.edit),
            url(r'^discuss/$', views.discuss),
            url(r'^permissions/$', views.permissions),
        ])),
    ]

.. _`Django 网站`: https://www.djangoproject.com/

捕获的参数
-------------------

被包含的 URLconf 会收到来之父 URLconf 捕获的任何参数，所以下面的例子是合法的::

    # In settings/urls/main.py
    from django.conf.urls import include, url

    urlpatterns = [
        url(r'^(?P<username>\w+)/blog/', include('foo.urls.blog')),
    ]

    # In foo/urls/blog.py
    from django.conf.urls import url
    from . import views

    urlpatterns = [
        url(r'^$', views.blog.index),
        url(r'^archive/$', views.blog.archive),
    ]

在上面的例子中，捕获的 ``"username"`` 变量将被如期传递给包含的 URLconf。

嵌套的参数
================

正则表达式允许嵌套的参数，Django 将解析它们并传递给视图。当反查时，Django 将尝试填满所有外围捕获的参数，并忽略嵌套捕获的参数。考虑下面的 URL 模式，它带有一个可选的 page 参数::

    from django.conf.urls import url

    urlpatterns = [
        url(r'blog/(page-(\d+)/)?$', blog_articles),                  # bad
        url(r'comments/(?:page-(?P<page_number>\d+)/)?$', comments),  # good
    ]

两个模式都使用嵌套的参数，其解析方式是：例如 ``blog/page-2/`` 将匹配 ``blog_articles`` 并带有两个位置参数：``page-2/`` 和 ``2``。第二个 ``comments`` 的模式将匹配 ``comments/page-2/`` 并带有一个值为 2 的关键字参数 ``page_number``。这个例子中外围参数是一个不捕获的参数 ``(?:...)``。

``blog_articles`` 视图需要最外层捕获的参数来反查，在这个例子中是 ``page-2/`` 或者没有参数，而 ``comments`` 可以不带参数或者用一个 ``page_number`` 值来反查。

嵌套捕获的参数使得视图参数和 URL 之间存在强耦合，正如 ``blog_articles``所示：视图接收 URL（``page-2/``）的一部分，而不只是视图感兴趣的值。这种耦合在反查时更加显著，因为反查视图时我们需要传递 URL 的一个片段而不只是 page 的值。

作为一个经验的法则，当正则表达式需要一个参数但视图忽略它的时候，只捕获视图需要的值并使用非捕获参数。

.. _views-extra-options:

传递额外的选项给视图函数
=======================================

URLconf 具有一个钩子，让你传递一个 Python 字典作为额外的参数传递给视图函数。

:func:`django.conf.urls.url` 函数可以接收一个可选的第三个参数，它是一个字典，表示想要传递给视图函数的额外关键字参数。

例如::

    from django.conf.urls import url
    from . import views

    urlpatterns = [
        url(r'^blog/(?P<year>[0-9]{4})/$', views.year_archive, {'foo': 'bar'}),
    ]

在这个例子中，对于 ``/blog/2005/`` 请求，Django 将调用 ``views.year_archive(request, year='2005', foo='bar')``。

这个技术在 :doc:`聚合框架 </ref/contrib/syndication>` 中使用，来传递元数据和选项给视图。

.. admonition:: 处理冲突

    URL 模式捕获的命名关键字参数和在字典中传递的额外参数有可能具有相同的名称。当这种情况发生时，将使用字典中的参数而不是 URL 中捕获的参数。

传递额外的选项给 ``include()``
--------------------------------------

类似地，你可以传递额外的选项给 :func:`~django.conf.urls.include`。当你传递额外的选项给 ``include()`` 时，被包含的 URLconf 的 *每一* 行将被传递这些额外的选项。

例如，下面两个 URLconf 设置功能上完全相同：

设置一::

    # main.py
    from django.conf.urls import include, url

    urlpatterns = [
        url(r'^blog/', include('inner'), {'blogid': 3}),
    ]

    # inner.py
    from django.conf.urls import url
    from mysite import views

    urlpatterns = [
        url(r'^archive/$', views.archive),
        url(r'^about/$', views.about),
    ]

设置二::

    # main.py
    from django.conf.urls import include, url
    from mysite import views

    urlpatterns = [
        url(r'^blog/', include('inner')),
    ]

    # inner.py
    from django.conf.urls import url

    urlpatterns = [
        url(r'^archive/$', views.archive, {'blogid': 3}),
        url(r'^about/$', views.about, {'blogid': 3}),
    ]

注意，额外的选项将 *总是* 传递给被包含的 URLconf 中的每一行，无论该行的视图实际上是否认为这些选项是合法的。由于这个原因，该技术只有当你确定被包含的 URLconf 中的每个视图都接收你传递给它们的额外的选项。

URL 的反向解析
==========================

在使用 Django 项目时，一个常见的需求是获得 URL 的最终形式，以用于嵌入到生成的内容中（视图中和显示给用户的URL等）或者用于处理服务器端的导航（重定向等）。

人们强烈希望不要硬编码这些 URL（费力、不可扩展且容易产生错误）或者设计一种与 URLconf 毫不相关的专门的 URL 生成机制，因为这样容易导致一定程度上产生过期的 URL。

换句话讲，需要的是一个 DRY 机制。除了其它有点，它还允许设计的 URL 可以自动更新而不用遍历项目的源代码来搜索并替换过期的 URL。

获取一个 URL 最开始想到的信息是处理它视图的标识（例如名字），查找正确的 URL 的其它必要的信息有视图参数的类型（位置参数、关键字参数）和值。

Django 提供一个办法是让 URL 映射是 URL 设计唯一的地方。你填充你的URLconf，然后可以双向使用它：

* 根据用户/浏览器发起的 URL 请求，它调用正确的 Django 视图，并从 URL 中提取它的参数需要的值。

* 根据 Django 视图的标识和将要传递给它的参数的值，获取与之关联的 URL。

第一种方式是我们在前面的章节中一直讨论的用法。第二种方式叫做 *反向解析 URL*、*反向 URL 匹配*、*反向 URL 查询* 或者简单的 *URL 反查*。

在需要 URL 的地方，对于不同层级，Django 提供不同的工具用于 URL 反查：

* 在模板中：使用 :ttag:`url` 模板标签。

* 在 Python 代码中：使用 :func:`~django.urls.reverse` 函数。

* 在更高层的与处理 Django 模型实例相关的代码中：使用 :meth:`~django.db.models.Model.get_absolute_url` 方法。

例子
--------

考虑下面的 URLconf::

    from django.conf.urls import url

    from . import views

    urlpatterns = [
        #...
        url(r'^articles/([0-9]{4})/$', views.year_archive, name='news-year-archive'),
        #...
    ]

根据这里的设计，某一年 *nnnn* 对应的归档的 URL 是 ``/articles/nnnn/``。

你可以在模板的代码中使用下面的方法获得它们：

.. code-block:: html+django

    <a href="{% url 'news-year-archive' 2012 %}">2012 Archive</a>
    {# Or with the year in a template context variable: #}
    <ul>
    {% for yearvar in year_list %}
    <li><a href="{% url 'news-year-archive' yearvar %}">{{ yearvar }} Archive</a></li>
    {% endfor %}
    </ul>

或在 Python 代码中::

    from django.urls import reverse
    from django.http import HttpResponseRedirect

    def redirect_to_year(request):
        # ...
        year = 2006
        # ...
        return HttpResponseRedirect(reverse('news-year-archive', args=(year,)))

如果出于某种原因决定按年归档文章发布的 URL 应该调整一下，那么你将只需要修改 URLconf 中的内容。

在某些场景中，一个视图是通用的，所以在 URL 和视图之间存在多对一的关系。对于这些情况，当反查 URL 时，只有视图的名字还不够。请阅读下一节来了解 Django 为这个问题提供的解决办法。

.. _naming-url-patterns:

命名 URL 模式
===================

为了完成上面例子中的 URL 反查，你将需要使用 **命名 URL 模式**。URL 的名称使用的字符串可以包含任何你喜欢的字符。不只限制在合法的 Python 名称。

当命名你的 URL 模式时，请确保使用的名称不会与其它应用中名称冲突。如果你的 URL 模式叫做 ``comment``，而另外一个应用中也有一个同样的名称，当你在模板中使用这个名称的时候不能保证将插入哪个 URL。

在 URL 名称中加上一个前缀，比如应用的名称，将减少冲突的可能。我们建议使用 ``myapp-comment`` 而不是 ``comment``。

.. _topics-http-defining-url-namespaces:

URL 命名空间
==============

简介
------------

URL 命名空间允许你反查到唯一的 :ref:`命名 URL 模式
<naming-url-patterns>`，即使不同的应用使用相同的 URL 名称。第三方应用始终使用带命名空间的 URL 是一个很好的实践（我们在教程中也是这么做的）。类似地，它还允许你在一个应用有多个实例部署的情况下反查 URL。换句话讲，因为一个应用的多个实例共享相同的命名 URL，命名空间将提供一种区分这些命名 URL 的方法。

在一个站点上，正确使用 URL 命名空间的 Django 应用可以部署多次。例如， :mod:`django.contrib.admin` 具有一个 :class:`~django.contrib.admin.AdminSite` 类，它允许你很容易地 :ref:`部署多个管理站点的实例 <multiple-admin-sites>`。在下面的例子中，我们将讨论在两个不同的地方部署教程中的 polls 应用，这样我们可以为两种不同的用户（作者和发布者）提供相同的功能。

一个 URL 命名空间有两个部分，它们都是字符串：

.. glossary::

  应用命名空间
    它表示正在部署的应用的名称。一个应用的每个实例具有相同的应用命名空间。例如，可以预见Django 的管理站点的应用命名空间是 ``'admin'``。

  实例命名空间
    它表示应用的一个特定的实例。实例的命名空间在你的全部项目中应该是唯一的。但是，一个实例的命名空间可以和应用的命名空间相同。它用于表示一个应用的默认实例。例如，Django 管理站点实例具有一个默认的实例命名空间 ``'admin'``。

URL 的命名空间使用 ``':'`` 操作符指定。例如，管理站点应用的主页使用 ``'admin:index'``。它表示 ``'admin'`` 的一个命名空间和 ``'index'`` 的一个命名 URL。

命名空间也可以嵌套。命名 URL ``'sports:polls:index'`` 将在命名空间 ``'polls'`` 中查找 ``'index'`` ，而 ``'polls'`` 定义在顶层的命名空间 ``'sports'`` 中。

.. _topics-http-reversing-url-namespaces:

反查带命名空间的 URL
-------------------------

当解析一个带命名空间的 URL（例如 ``'polls:index'``）时，Django 将切分名称为多个部分，然后按下面的步骤查找：

1. 首先，Django 查找匹配的 :term:`应用命名空间` （在这个例子中为 ``'polls'``）。这将得到该应用实例的一个列表。

2. 如果有定义当前应用，Django 将查找并返回那个实例的 URL 解析器。当前 应用可以通过 :func:`~django.urls.reverse()` 函数的 ``current_app`` 参数指定。

   The :ttag:`url` template tag uses the namespace of the currently resolved
   view as the current application in a
   :class:`~django.template.RequestContext`. You can override this default by
   setting the current application on the :attr:`request.current_app
   <django.http.HttpRequest.current_app>` attribute.

   .. versionchanged:: 1.9

      Previously, the :ttag:`url` template tag did not use the namespace of the
      currently resolved view and you had to set the ``current_app`` attribute
      on the request.

3. 如果没有当前应用。Django 将查找一个默认的应用实例。默认的应用实例是 :term:`实例命名空间` 与 :term:`应用命名空间` 一致的那个实例（在这个例子中，``polls`` 的一个叫做``'polls'`` 的实例）。

4. 如果没有默认的应用实例，Django 将该应用挑选最后部署的实例，不管实例的名称是什么。

5. 如果提供的命名空间与第 1 步中的 :term:`应用命名空间` 不匹配，Django 将尝试直接将此命名空间作为一个 :term:`实例命名空间` 查找。

如果有嵌套的命名空间，将为命名空间的每个部分重复调用这些步骤直至剩下视图的名称还未解析。然后该视图的名称将被解析到找到的这个命名空间中的一个URL。

例子
~~~~~~~

为了演示解析的策略，考虑教程中 ``polls`` 应用的两个实例：一个叫 ``'author-polls'`` 另一个叫  ``'publisher-polls'``。假设我们已经增强了该应用，在创建和显示投票时考虑了实例命名空间。

.. snippet::
    :filename: urls.py

    from django.conf.urls import include, url

    urlpatterns = [
        url(r'^author-polls/', include('polls.urls', namespace='author-polls')),
        url(r'^publisher-polls/', include('polls.urls', namespace='publisher-polls')),
    ]

.. snippet::
    :filename: polls/urls.py

    from django.conf.urls import url

    from . import views

    app_name = 'polls'
    urlpatterns = [
        url(r'^$', views.IndexView.as_view(), name='index'),
        url(r'^(?P<pk>\d+)/$', views.DetailView.as_view(), name='detail'),
        ...
    ]

根据以上设置，可以使用下面的查询：

* 如果其中一个实例是当前实例 —— 如果我们正在渲染 ``'author-polls'`` 实例的详情页面 —— ``'polls:index'`` 将解析成 ``'author-polls'`` 实例的主页面；例如下面两个都将解析成 ``"/author-polls/"``。

  在基于类的视图的方法中::

    reverse('polls:index', current_app=self.request.resolver_match.namespace)

  和在模板中：

  .. code-block:: html+django

    {% url 'polls:index' %}

* 如果没有当前实例 —— 如果我们在站点的其它地方渲染一个页面 —— ``'polls:index'`` 将解析到最后注册的 ``polls`` 的一个实例。因为没有默认的实例（命名空间为 ``'polls'``的实例），将使用注册的 ``polls`` 的最后一个实例。它将是 ``'publisher-polls'``，因为它是在 ``urlpatterns`` 中最后一个声明的。

* ``'author-polls:index'`` 将总是解析到 ``'author-polls'`` 实例的主页（ ``'publisher-polls'`` 类似）。

如果还有一个默认的实例 —— 例如，一个名为 ``'polls'`` 的实例 —— 上面例子中唯一的变化是当没有当前实例的情况（上述第二种情况）。在这种情况下 ``'polls:index'`` 将解析到默认实例而不是 ``urlpatterns`` 中最后声明的实例的主页。

.. _namespaces-and-include:

URL 命名空间和被包含的 URLconf
------------------------------------

被包含的 URLconf 的应用命名空间可以通过两种方式指定。

首先，你可以在你被包含的 URLconf 模块中设置 ``app_name`` 属性，和 ``urlpatterns`` 属性同级。You have to pass the actual
module, or a string reference to the module, to
:func:`~django.conf.urls.include`, not the list of ``urlpatterns`` itself.

.. snippet::
    :filename: polls/urls.py

    from django.conf.urls import url

    from . import views

    app_name = 'polls'
    urlpatterns = [
        url(r'^$', views.IndexView.as_view(), name='index'),
        url(r'^(?P<pk>\d+)/$', views.DetailView.as_view(), name='detail'),
        ...
    ]

.. snippet::
    :filename: urls.py

    from django.conf.urls import include, url

    urlpatterns = [
        url(r'^polls/', include('polls.urls')),
    ]

这将包含 ``polls.urls`` 中定义的 URL 到应用命名空间 ``polls``。

其次，你可以 include 一个包含嵌套命名空间数据的对象。如果你 ``include()`` 一个 :func:`~django.conf.urls.url` 实例的列表，那么该对象中包含的 URL 将添加到全局命名空间。

再或者，你还可以 ``include()`` 一个 2 个元素的元组::

    (<list of url() instances>, <application namespace>)

例如::

    from django.conf.urls import include, url

    from . import views

    polls_patterns = ([
        url(r'^$', views.IndexView.as_view(), name='index'),
        url(r'^(?P<pk>\d+)/$', views.DetailView.as_view(), name='detail'),
    ], 'polls')

    urlpatterns = [
        url(r'^polls/', include(polls_patterns)),
    ]

这将 include 命名的 URL 模式到给定的应用和实例命名空间中。

The instance namespace can be specified using the ``namespace`` argument to
:func:`~django.conf.urls.include`. If the instance namespace is not specified,
it will default to the included URLconf's application namespace. This means
it will also be the default instance for that namespace.

.. versionchanged:: 1.9

    In previous versions, you had to specify both the application namespace
    and the instance namespace in a single place, either by passing them as
    parameters to :func:`~django.conf.urls.include` or by including a 3-tuple
    containing
    ``(<list of url() instances>, <application namespace>, <instance namespace>)``.
