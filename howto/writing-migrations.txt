===========================
编写数据库迁移
===========================

这一节介绍你可能遇到的在不同情况下如何分析和编写数据库迁移. 有关迁移的入门资料，请查看 :doc:`主题指南 </topics/migrations>`。

.. _data-migrations-and-multiple-databases:

数据迁移和多数据库
======================================

在使用多个数据库时，需要解决是否针对某个特定数据库运行迁移。例如，你可能 **只** 想在某个特定数据库上运行迁移。

为此你可以在 ``RunPython`` 中通过查看 ``schema_editor.connection.alias`` 属性来检查数据库连接别名::

    from django.db import migrations

    def forwards(apps, schema_editor):
        if not schema_editor.connection.alias == 'default':
            return
        # Your migration code goes here

    class Migration(migrations.Migration):

        dependencies = [
            # Dependencies to other migrations
        ]

        operations = [
            migrations.RunPython(forwards),
        ]

你也可以提供一个提示作为 ``**hints`` 参数传递到数据库路由的 :meth:`allow_migrate()` 方法：

.. snippet::
    :filename: myapp/dbrouters.py

    class MyRouter(object):

        def allow_migrate(self, db, app_label, model_name=None, **hints):
            if 'target_db' in hints:
                return db == hints['target_db']
            return True

然后，要在你的迁移中利用，执行以下操作::

    from django.db import migrations

    def forwards(apps, schema_editor):
        # Your migration code goes here
        ...

    class Migration(migrations.Migration):

        dependencies = [
            # Dependencies to other migrations
        ]

        operations = [
            migrations.RunPython(forwards, hints={'target_db': 'default'}),
        ]

如果你的 ``RunPython`` 或者 ``RunSQL`` 操作只对一个模型有影响，最佳实践是将 ``model_name`` 作为提示传递，使其尽可能对路由可见。这对可复用的和第三方应用极其重要。

添加唯一字段的迁移
=================================

如果你应用了一个“朴素”的迁移，向表中一个已存在的行中添加了一个唯一的非空字段，会产生错误，因为位于已存在行中的值只会生成一次。所以需要移除唯一性的约束。

所以，应该执行下面的步骤。在这个例子中，我们会以默认值添加一个非空的 :class:`~django.db.models.UUIDField` 字段。你可以根据你的需要修改各个字段。

* 把 ``default=uuid.uuid4`` 和 ``unique=True`` 参数添加到你模型的字段中（为你添加的字段的类型选择一个适当的默认值）。

* 运行 :djadmin:`makemigrations` 命令。这应该生成一个 ``AddField`` 的迁移操作。

* Generate two empty migration files for the same app by running
  ``makemigrations myapp --empty`` twice. We've renamed the migration files to
  give them meaningful names in the examples below.

* Copy the ``AddField`` operation from the auto-generated migration (the first
  of the three new files) to the last migration and change ``AddField`` to
  ``AlterField``. For example:

  .. snippet::
    :filename: 0006_remove_uuid_null.py

    # -*- coding: utf-8 -*-
    # Generated by Django A.B on YYYY-MM-DD HH:MM
    from __future__ import unicode_literals

    from django.db import migrations, models
    import uuid


    class Migration(migrations.Migration):

        dependencies = [
            ('myapp', '0005_populate_uuid_values'),
        ]

        operations = [
            migrations.AlterField(
                model_name='mymodel',
                name='uuid',
                field=models.UUIDField(default=uuid.uuid4, unique=True),
            ),
        ]

* 编辑第一个迁移文件。生成的迁移类看上去像这样:

  .. snippet::
    :filename: 0004_add_uuid_field.py

    class Migration(migrations.Migration):

        dependencies = [
            ('myapp', '0003_auto_20150129_1705'),
        ]

        operations = [
            migrations.AddField(
                model_name='mymodel',
                name='uuid',
                field=models.UUIDField(default=uuid.uuid4, unique=True),
            ),
        ]

  Change ``unique=True`` to ``null=True`` -- this will create the intermediary
  null field and defer creating the unique constraint until we've populated
  unique values on all the rows.

* In the first empty migration file, add a
  :class:`~django.db.migrations.operations.RunPython` or
  :class:`~django.db.migrations.operations.RunSQL` operation to generate a
  unique value (UUID in the example) for each existing row. For example:

  .. snippet::
    :filename: 0005_populate_uuid_values.py

    # -*- coding: utf-8 -*-
    # Generated by Django A.B on YYYY-MM-DD HH:MM
    from __future__ import unicode_literals

    from django.db import migrations, models
    import uuid

    def gen_uuid(apps, schema_editor):
        MyModel = apps.get_model('myapp', 'MyModel')
        for row in MyModel.objects.all():
            row.uuid = uuid.uuid4()
            row.save()

    class Migration(migrations.Migration):

        dependencies = [
            ('myapp', '0004_add_uuid_field'),
        ]

        operations = [
            # omit reverse_code=... if you don't want the migration to be reversible.
            migrations.RunPython(gen_uuid, reverse_code=migrations.RunPython.noop),
        ]

* 现在你可以像平常一样使用 :djadmin:`migrate` 命令应用迁移。

  注意如果你在这个迁移运行时让对象被创建，就会产生紊乱情况。在 ``AddField`` 之后，``RunPython`` 之前创建的对象会覆写他们原始的 ``uuid``。

.. _non-atomic-migrations:

Non-atomic migrations
~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.10

On databases that support DDL transactions (SQLite and PostgreSQL), migrations
will run inside a transaction by default. For use cases such as performing data
migrations on large tables, you may want to prevent a migration from running in
a transaction by setting the ``atomic`` attribute to ``False``::

    from django.db import migrations

    class Migration(migrations.Migration):
        atomic = False

Within such a migration, all operations are run without a transaction. It's
possible to execute parts of the migration inside a transaction using
:func:`~django.db.transaction.atomic()` or by passing ``atomic=True`` to
``RunPython``.

Here's an example of a non-atomic data migration that updates a large table in
smaller batches::

    import uuid

    from django.db import migrations, transaction

    def gen_uuid(apps, schema_editor):
        MyModel = apps.get_model('myapp', 'MyModel')
        while MyModel.objects.filter(uuid__isnull=True).exists():
            with transaction.atomic():
                for row in MyModel.objects.filter(uuid__isnull=True)[:1000]:
                    row.uuid = uuid.uuid4()
                    row.save()

    class Migration(migrations.Migration):
        atomic = False

        operations = [
            migrations.RunPython(gen_uuid),
        ]

The ``atomic`` attribute doesn't have an effect on databases that don't support
DDL transactions (e.g. MySQL, Oracle).

Controlling the order of migrations
===================================

Django determines the order in which migrations should be applied not by the
filename of each migration, but by building a graph using two properties on the
``Migration`` class: ``dependencies`` and ``run_before``.

If you've used the :djadmin:`makemigrations` command you've probably
already seen ``dependencies`` in action because auto-created
migrations have this defined as part of their creation process.

The ``dependencies`` property is declared like this::

    from django.db import migrations

    class Migration(migrations.Migration):

        dependencies = [
            ('myapp', '0123_the_previous_migration'),
        ]

Usually this will be enough, but from time to time you may need to
ensure that your migration runs *before* other migrations. This is
useful, for example, to make third-party apps' migrations run *after*
your :setting:`AUTH_USER_MODEL` replacement.

To achieve this, place all migrations that should depend on yours in
the ``run_before`` attribute on your ``Migration`` class::

    class Migration(migrations.Migration):
        ...

        run_before = [
            ('third_party_app', '0001_do_awesome'),
        ]

Prefer using ``dependencies`` over ``run_before`` when possible. You should
only use ``run_before`` if it is undesirable or impractical to specify
``dependencies`` in the migration which you want to run after the one you are
writing.

Migrating data between third-party apps
=======================================

You can use a data migration to move data from one third-party application to
another.

If you plan to remove the old app later, you'll need to set the ``dependencies``
property based on whether or not the old app is installed. Otherwise, you'll
have missing dependencies once you uninstall the old app. Similarly, you'll
need to catch :exc:`LookupError` in the ``apps.get_model()`` call that
retrieves models from the old app. This approach allows you to deploy your
project anywhere without first installing and then uninstalling the old app.

Here's a sample migration:

.. snippet::
    :filename: myapp/migrations/0124_move_old_app_to_new_app.py

    from django.apps import apps as global_apps
    from django.db import migrations

    def forwards(apps, schema_editor):
        try:
            OldModel = apps.get_model('old_app', 'OldModel')
        except LookupError:
            # The old app isn't installed.
            return

        NewModel = apps.get_model('new_app', 'NewModel')
        NewModel.objects.bulk_create(
            NewModel(new_attribute=old_object.old_attribute)
            for old_object in OldModel.objects.all()
        )

    class Migration(migrations.Migration):
        operations = [
            migrations.RunPython(forwards, migrations.RunPython.noop),
        ]
        dependencies = [
            ('myapp', '0123_the_previous_migration'),
            ('new_app', '0001_initial'),
        ]

        if global_apps.is_installed('old_app'):
            dependencies.append(('old_app', '0001_initial'))

Also consider what you want to happen when the migration is unapplied. You
could either do nothing (as in the example above) or remove some or all of the
data from the new application. Adjust the second argument of the
:mod:`~django.db.migrations.operations.RunPython` operation accordingly.

Changing an unmanaged model to managed
======================================

If you want to change an unmanaged model (:attr:`managed=False
<django.db.models.Options.managed>`) to managed, you must remove
``managed=False`` and generate a migration before making other schema-related
changes to the model, since schema changes that appear in the migration that
contains the operation to change ``Meta.managed`` may not be applied.
