==========================
``QuerySet`` API 参考
==========================

.. currentmodule:: django.db.models.query

本文档描述了 ``QuerySet`` API 的详细信息。它建立在 :doc:`模型 </topics/db/models>` 和 :doc:`数据库查询 </topics/db/queries>` 指南的基础上，所以在阅读本文档之前，你也许需要首先阅读这两部分的文档。

本文档将通篇使用在 :doc:`数据库查询指南 </topics/db/queries>` 中用到的 :ref:`Weblog 模型的例子 <queryset-model-example>` 。

.. _when-querysets-are-evaluated:

何时对 ``QuerySet`` 求值
=================================

在内部，``QuerySet`` 可以创建、过滤、切片和传递而不用真实操作数据库。在你对查询集做求值之前，不会发生任何实际的数据库操作。

你可以使用下列方法对 ``QuerySet`` 求值：

* **迭代。** ``QuerySet`` 是可迭代的，它在首次迭代查询集时执行实际的数据库查询。例如， 下面的语句会将数据库中所有 Entry 的 headline 打印出来::

      for e in Entry.objects.all():
          print(e.headline)

  注意：不要使用上面的语句来验证在数据库中是否至少存在一条记录。使用 :meth:`~QuerySet.exists` 方法更高效。

* **切片。** 正如在 :ref:`limiting-querysets` 中解释的那样，可以使用 Python 的序列切片语法对一个 ``QuerySet`` 进行分片。一个未求值的 ``QuerySet`` 进行切片通常返回另一个未求值的 ``QuerySet`` ，但是如果你使用切片的 "step" 参数，Django 将执行数据库查询并返回一个列表。对一个已经求值的 ``QuerySet`` 进行切片将返回一个列表。

  还要注意，虽然对未求值的 ``QuerySet`` 进行切片返回另一个未求值的 ``QuerySet`` ，但是却不可以进一步修改它了（例如，添加更多的 filter，或者修改排序的方式），因为这将不太好翻译成 SQL 而且含义也不清晰。

* **序列化/缓存。** `序列化 QuerySets`_ 的细节参见下面一节。本节提到它的目的是强调序列化将读取数据库。

* **repr()。** 当对 ``QuerySet`` 调用 ``repr()`` 时，将对它求值。这是为了在 Python 交互式解释器中使用的方便，这样你可以在交互式使用这个 API 时立即看到结果。

* **len()。** 当你对 ``QuerySet`` 调用 ``len()`` 时， 将对它求值。正如你期望的那样，返回一个查询结果集的长度。

  注：如果你只需要知道集合中记录的个数（并不需要真实的对象），使用数据库层级的 ``SELECT COUNT(*)`` 计数将更加高效。为此，Django 提供了一个 :meth:`~QuerySet.count` 方法。

* **list()。** 对 ``QuerySet`` 调用 ``list()`` 将强制对它求值。例如::

      entry_list = list(Entry.objects.all())

* **bool()。** 测试一个 ``QuerySet`` 的布尔值，例如使用 ``bool()`` 、 ``or`` 、 ``and`` 或者 ``if`` 语句将导致查询集的执行。如果至少有一个记录，则 ``QuerySet`` 为 ``True`` ，否则为 ``False``。例如::

      if Entry.objects.filter(headline="Test"):
         print("There is at least one Entry with the headline Test")

  注：如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用 :meth:`~QuerySet.exists` 将更加高效。

.. _序列化 QuerySets:

序列化 ``QuerySet``
-----------------------

如果你 :mod:`pickle` 一个 ``QuerySet``，它将在序列化之前强制将所有的结果加载到内存中。序列化通常用于缓存之前，并且当缓存的查询集重新加载时，你希望结果已经存在随时准备使用（从数据库读取耗费时间，就失去了缓存的目的）。这意味着当你反序列化 ``QuerySet`` 时，它包含序列化时的结果，而不是当前数据库中的结果。

如果此后你只想序列化必要的信息来从数据库重新创建 ``QuerySet`` ，可以序列化 ``QuerySet`` 的 ``query`` 属性。然后你可以使用类似下面的代码重新创建原始的 ``QuerySet`` （不用加载任何结果）::

    >>> import pickle
    >>> query = pickle.loads(s)     # Assuming 's' is the pickled string.
    >>> qs = MyModel.objects.all()
    >>> qs.query = query            # Restore the original 'query'.

``query`` 是一个不透明的对象。它表示查询的内部构造，不属于公开的 API。然而，这里讲到的序列化
和反序列化这个属性的内容是安全的（和完全支持的）。

.. admonition:: 不可以在不同版本之间共享序列化的结果

    ``QuerySets`` 的序列化只能用于生成它们的 Django 版本中。如果你使用 Django 的版本 N 生成一个序列，不保证这个序列在 Django 的版本 N+1 中可以读取。序列化不可用于归档的长期策略。

    因为序列化兼容性的错误很难诊断例如产生损坏的对象，当你试图反序列化的查询集与序列化时的 Django 版本不同，将引发一个 ``RuntimeWarning``。

.. _queryset-api:

``QuerySet`` API
================

下面是对于 ``QuerySet`` 的正式定义：

.. class:: QuerySet(model=None, query=None, using=None)

    通常你在使用 ``QuerySet`` 时会以 :ref:`链式的 <chaining-filters>` 来使用。为了让这个能工作，大部分 ``QuerySet`` 方法返回新的 queryset。这些方法在本节将详细讲述。

    ``QuerySet`` 类具有两个公有属性用于内省：

    .. attribute:: ordered

        如果 ``QuerySet`` 是排好序的则为 ``True`` —— 例如有一个 :meth:`order_by()` 子句或者模型有默认的排序。否则为 ``False``。

    .. attribute:: db

        如果现在执行，则返回将使用的数据库。

    .. note::

        :class:`QuerySet` 存在 ``query`` 参数是为了让具有特殊查询用途的子类如 :class:`~django.contrib.gis.db.models.GeoQuerySet` 可以重新构造内部的查询状态。这个参数的值是查询状态的不透明的表示，不是一个公开的 API。简而言之：如果你有疑问，那么你实际上不需要使用它。

.. currentmodule:: django.db.models.query.QuerySet

返回新的 ``QuerySet`` 的方法
--------------------------------------

Django 提供了一系列的 ``QuerySet`` 筛选方法，用于改变 ``QuerySet`` 返回的结果类型或者 SQL 查询执行的方式。

``filter()``
~~~~~~~~~~~~

.. method:: filter(**kwargs)

返回一个新的 ``QuerySet``，包含与给定的查询参数匹配的对象。

查找的参数（``**kwargs``) 应该满足下文 `Field 查找`_ 中的格式。在底层的 SQL 语句中，多个参数通过 ``AND`` 连接。

如果你需要执行更复杂的查询（例如，使用 ``OR`` 语句查询），你可以使用 :class:`Q 对象 <django.db.models.Q>`。

``exclude()``
~~~~~~~~~~~~~

.. method:: exclude(**kwargs)

返回一个新的 ``QuerySet``，它包含*不*满足给定的查找参数的对象。

查找的参数（``**kwargs``）应该满足下文 `Field 查找`_ 中的格式。 在底层的 SQL 语句中，多个参数通过 ``AND`` 连接，然后所有的内容放入 ``NOT()`` 中。

下面的示例排除所有 ``pub_date``  晚于 2005-1-3 且 ``headline`` 为“Hello”的记录::

    Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline='Hello')

用 SQL 语句，它等同于::

    SELECT ...
    WHERE NOT (pub_date > '2005-1-3' AND headline = 'Hello')

下面的示例排除所有 ``pub_date`` 晚于 2005-1-3 或者 headline 为“Hello”的记录::

    Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3)).exclude(headline='Hello')

用 SQL 语句，它等同于::

    SELECT ...
    WHERE NOT pub_date > '2005-1-3'
    AND NOT headline = 'Hello'

注意，第二个示例更严格。

如果你需要执行更复杂的查询（例如，使用 ``OR`` 语句查询），你可以使用 :class:`Q 对象 <django.db.models.Q>`。

``annotate()``
~~~~~~~~~~~~~~

.. method:: annotate(*args, **kwargs)

使用提供的 :doc:`查询表达式 </ref/models/expressions>` Annotates ``QuerySet`` 中的每个对象。查询表达式可以是一个简单的值、模型（或关联模型）字段的一个引用或对 ``QuerySet`` 中的对象一个聚合函数（平均值、和等）。

``annotate()`` 的每个参数都是一个 annotation ，它将添加到返回的 ``QuerySet`` 中每个对象。

Django 提供的聚合函数在下文的 `聚合函数`_ 文档中讲述。

关键字参数指定的 Annotation 将使用关键字作为 Annotation 的别名。匿名的参数的别名将基于聚合函数的名称和模型的字段生成。只有引用单个字段的聚合表达式才可以使用匿名参数。其它所有形式都必须用关键字参数。

例如，如果你正在操作一个 Blog 列表，你可能想知道每个 Blog 有多少 Entry::

    >>> from django.db.models import Count
    >>> q = Blog.objects.annotate(Count('entry'))
    # The name of the first blog
    >>> q[0].name
    'Blogasaurus'
    # The number of entries on the first blog
    >>> q[0].entry__count
    42

``Blog`` 模型本身没有定义 ``entry__count`` 属性，但是通过使用一个关键字参数来指定聚合函数，你可以控制 Annotation 的名称::

    >>> q = Blog.objects.annotate(number_of_entries=Count('entry'))
    # The number of entries on the first blog, using the name provided
    >>> q[0].number_of_entries
    42

聚合的深入讨论，参见 :doc:`聚合主题的指南 </topics/db/aggregation>`。

``order_by()``
~~~~~~~~~~~~~~

.. method:: order_by(*fields)

默认情况下，``QuerySet`` 根据模型 ``Meta`` 类的 ``ordering`` 选项排序。你可以使用 ``order_by`` 方法给每个 ``QuerySet`` 指定特定的排序。

例如::

    Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')

上面的结果将按照 ``pub_date`` 降序排序，然后再按照 ``headline`` 升序排序。``"-pub_date"`` 前面的负号表示降序排序。隐式的是升序排序。若要随机排序，请使用 ``"?"``，像这样::

    Entry.objects.order_by('?')

注: ``order_by('?')`` 查询可能耗费资源且很慢，这取决于使用的数据库。

若要按照另外一个模型中的字段排序，可以使用查询关联模型时的语法。即通过字段的名称后面跟上两个下划线（``__``），再跟上新模型中的字段的名称，直至你希望连接的模型。例如::

    Entry.objects.order_by('blog__name', 'headline')

如果排序的字段与另外一个模型关联，Django 将使用关联的模型的默认排序，或者如果没有指定 :attr:`Meta.ordering <django.db.models.Options.ordering>` 将通过关联的模型的主键排序。例如，因为 ``Blog`` 模型没有指定默认的排序::

    Entry.objects.order_by('blog')

...等同于::

    Entry.objects.order_by('blog__id')

如果 ``Blog`` 设置 ``ordering = ['name']``，那么第一个查询集将等同于::

    Entry.objects.order_by('blog__name')

通过关联字段排序查询集还能够不用带来 JOIN  产生的花费，方法是引用关联字段的 ``_id``::

    # No Join
    Entry.objects.order_by('blog_id')

    # Join
    Entry.objects.order_by('blog__id')

你还可以通过调用表达式的 ``asc()`` 或者 ``desc()``，根据 :doc:`查询表达式 </ref/models/expressions>` 排序::

    Entry.objects.order_by(Coalesce('summary', 'headline').desc())

如果你还用到 :meth:`distinct()`，在根据关联模型中的字段排序时要小心。:meth:`distinct` 中有一个备注讲述关联模型的排序如何对结果产生影响。

.. note::
    指定一个多值字段来排序结果（例如，一个 :class:`~django.db.models.ManyToManyField` 字段或者 :class:`~django.db.models.ForeignKey` 字段的反向关联）。

    考虑下面的情况::

         class Event(Model):
            parent = models.ForeignKey(
                'self',
                on_delete=models.CASCADE,
                related_name='children',
            )
            date = models.DateField()

         Event.objects.order_by('children__date')

    这里，每个 ``Event`` 可能有多个潜在的排序数据；``Event`` with multiple ``children`` will be returned multiple times
    into the new ``QuerySet`` that ``order_by()`` creates. 换句话说, 用 ``order_by()`` 方法对 ``QuerySet`` 对象进行操作会返回一个扩大版的新 ``QuerySet`` 对象 —— 新增的条目也许并没有什么用，你也用不着它们。

    因此，当你使用多值字段对结果进行排序时要格外小心。**如果**，您可以确保每个订单项只有一个订购数据，这种方法不会出现问题。如果不确定，请确保结果是你期望的。

没有方法指定排序是否考虑大小写。对于大小写的敏感性，Django 将根据数据库中的排序方式排序结果。

你可以通过 :class:`~django.db.models.functions.Lower` 将一个字段转换为小写来排序，它将达到大小写一致的排序::

    Entry.objects.order_by(Lower('headline').desc())

如果你不想对查询做任何排序，即使是默认的排序，可以不带参数调用 :meth:`order_by()`。

你可以通过检查 :attr:`.QuerySet.ordered` 属性来知道查询是否是排序的，如果 ``QuerySet`` 有任何方式的排序它将为 ``True``。

每个 ``order_by()`` 都将清除前面的任何排序。例如，下面的查询将按照 ``pub_date`` 排序，而不是 ``headline``::

    Entry.objects.order_by('headline').order_by('pub_date')

.. warning::

    排序不是没有开销的操作。添加到排序中的每个字段都将带来数据库的开销。添加的每个外键也都将隐式包含进它的默认排序。

    如果查询未指定排序，则以未指定的顺序从数据库返回结果。只有当通过唯一地标识结果中的每个对象的一组字段进行排序时，才保证特定的排序。例如，如果一个 ``name`` 字段不是唯一的，它的排序并不能保证同名的对象总是以相同的顺序出现。

``reverse()``
~~~~~~~~~~~~~

.. method:: reverse()

``reverse()`` 方法反向排序查询集中返回的元素。第二次调用 ``reverse()`` 将恢复到原有的排序。

如要获取查询集中最后五个元素，你可以这样做::

    my_queryset.reverse()[:5]

注意，这与 Python 中从一个序列的末尾进行切片有点不一样。上面的例子将首先返回最后一个元素，然后是倒数第二个元素，以此类推。如果我们有一个 Python 序列，当我们查看 ``seq[-5:]`` 时，我们将一下子得到倒数五个元素。Django 不支持这种访问模型（从末尾进行切片），因为它不可能利用 SQL 高效地实现。

同时还要注意，``reverse()`` 应该只在一个已经定义排序的 ``QuerySet`` 上调用（例如，在一个定义了默认排序的模型上，或者使用 :meth:`order_by()` 的时候）。如果 ``QuerySet`` 没有定义排序，调用 ``reverse()`` 将不会有任何效果（在调用 ``reverse()`` 之前没有定义排序，那么调用之后仍保持没有定义）。

``distinct()``
~~~~~~~~~~~~~~

.. method:: distinct(*fields)

返回一个在 SQL 查询中使用 ``SELECT DISTINCT`` 的新 ``QuerySet``。它将去除查询结果中重复的行。

默认情况下，``QuerySet`` 不会去除重复的行。在实际应用中，这一般不是个问题，因为像 ``Blog.objects.all()`` 这样的简单查询不会引入重复的行。但是，如果查询跨越多张表，当对 ``QuerySet`` 求值时就可能得到重复的结果。这时候你应该使用 ``distinct()``。

.. note::
    :meth:`order_by` 调用中的任何字段都将包含在 SQL 的 ``SELECT`` 列中。与 ``distinct()`` 一起使用时可能导致预计不到的结果。如果你根据关联模型的字段排序，这些 fields 将添加到查询的字段中，它们可能产生本应该是唯一的重复的行。因为多余的列没有出现在返回的结果中（它们只是为了支持排序），有时候看上去像是返回了不明确的结果。

    类似地，如果您使用 :meth:`values()` 查询来限制所选择的列，则仍然会涉及任何 :meth:`order_by()` （或默认模型排序）影响结果的唯一性。

    这里的道德是，如果你使用 ``distinct()`` 小心有关的模型排序。类似地，当一起使用 ``distinct()`` 和 :meth:`values()` 时，请注意字段在不在 :meth:`values()`。

在 PostgreSQL 上，您可以传递位置参数（``*fields``），以便指定 ``DISTINCT`` 应该应用的字段的名称。这转换为 ``SELECT DISTINCT ON`` SQL 查询。这里有区别。对于正常的 ``distinct()`` 调用，数据库在确定哪些行不同时比较每行中的 *每* 个字段。对于具有指定字段名称的 ``distinct()`` 调用，数据库将仅比较指定的字段名称。

.. note::
    当你指定字段名称时，*必须* 在 ``QuerySet`` 中提供 ``order_by()``，而且 ``order_by()`` 中的字段必须以 ``distinct()`` 中的字段相同开始并且顺序相同。

    例如，``SELECT DISTINCT ON (a)`` 列 ``a`` 中的每个值。如果你没有指定一个顺序，你会得到一个任意的行。

示例（除第一个示例外，其他示例都只能在 PostgreSQL 上工作）::

    >>> Author.objects.distinct()
    [...]

    >>> Entry.objects.order_by('pub_date').distinct('pub_date')
    [...]

    >>> Entry.objects.order_by('blog').distinct('blog')
    [...]

    >>> Entry.objects.order_by('author', 'pub_date').distinct('author', 'pub_date')
    [...]

    >>> Entry.objects.order_by('blog__name', 'mod_date').distinct('blog__name', 'mod_date')
    [...]

    >>> Entry.objects.order_by('author', 'pub_date').distinct('author')
    [...]

.. note::
    请记住，:meth:`order_by` 使用已定义的任何默认相关模型排序。您可能需要通过关系 ``_id`` 或引用字段显式排序，以确保 ``DISTINCT ON`` 在 ``ORDER BY`` 子句的开头。例如，如果 ``Blog`` 模型通过 ``name`` 定义 :attr:`~django.db.models.Options.ordering`::

        Entry.objects.order_by('blog').distinct('blog')

    ...无法工作，因为查询将按 ``blog__name`` 排序，从而使 ``DISTINCT ON`` 表达式不匹配。你必须按照关系 `_id` 字段（在这种情况下为 ``blog_id``）或引用的（``blog__pk``）显式排序来确保两个表达式都匹配。

``values()``
~~~~~~~~~~~~

.. method:: values(*fields)

返回一个迭代时返回字典而不是模型实例对象的 ``QuerySet``。

每个字典表示一个对象，键对应于模型对象的属性名称。

下面的例子将 ``values()`` 与普通的模型对象进行比较::

    # This list contains a Blog object.
    >>> Blog.objects.filter(name__startswith='Beatles')
    <QuerySet [<Blog: Beatles Blog>]>

    # This list contains a dictionary.
    >>> Blog.objects.filter(name__startswith='Beatles').values()
    <QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]>

``values()`` 接收可选的位置参数 ``*fields``，它指定 ``SELECT`` 应该限制哪些字段。如果指定字段，每个字典将只包含指定的字段的键/值。如果没有指定字段，每个字典将包含数据库表中所有字段的键和值。

例如::

    >>> Blog.objects.values()
    <QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]>
    >>> Blog.objects.values('id', 'name')
    <QuerySet [{'id': 1, 'name': 'Beatles Blog'}]>

值得注意的几点：

* 如果你有一个字段 ``foo`` 是一个 :class:`~django.db.models.ForeignKey`，默认的 ``values()`` 调用返回的字典将有一个叫做 ``foo_id`` 的键，因为这是保存实际的值的那个隐藏的模型属性的名称（``foo`` 属性引用关联的模型）。当你调用 ``values()`` 并传递字段的名称，传递 ``foo`` 或 ``foo_id`` 都可以，得到的结果是相同的（字典的键会与你传递的字段名匹配）。

  例如::

    >>> Entry.objects.values()
    <QuerySet [{'blog_id': 1, 'headline': 'First Entry', ...}, ...]>

    >>> Entry.objects.values('blog')
    <QuerySet [{'blog': 1}, ...]>

    >>> Entry.objects.values('blog_id')
    <QuerySet [{'blog_id': 1}, ...]>

* 当 ``values()`` 与 :meth:`distinct()` 一起使用时，注意排序可能影响最终的结果。详细信息参见 :meth:`distinct` 中的备注。

* 如果 ``values()`` 子句位于 :meth:`extra()` 调用之后，:meth:`extra()` 中的 ``select`` 参数定义的字段必须显式包含在 ``values()`` 调用中。``values()`` 调用后面的 :meth:`extra()` 调用将忽略选择的额外的字段。

* 在 ``values()`` 之后调用 :meth:`only()` 和 :meth:`defer()` 不太合理，所以将引发一个 ``NotImplementedError``。

它用于你知道你只需要字段的一小部分，而不需要用到模型实例对象的函数。只选择用到的字段当然更高效。

最后，要注意在 ``values()`` 调用后，你可以对它调用 ``filter()``、``order_by()`` 等等。这表示下面的两个调用完全相同::

    Blog.objects.values().order_by('id')
    Blog.objects.order_by('id').values()

Django 的作者喜欢将影响 SQL 的方法放在前面，然后放置影响输出的方法（例如 ``values()``），但是实际上无所谓。这是卖弄你个性的好机会。

你可以通过 ``OneToOneField``、``ForeignKey`` 和 ``ManyToManyField`` 属性反向引用关联的模型的字段::

    >>> Blog.objects.values('name', 'entry__headline')
    <QuerySet [{'name': 'My blog', 'entry__headline': 'An entry'},
         {'name': 'My blog', 'entry__headline': 'Another entry'}, ...]>

.. warning::

   因为 :class:`~django.db.models.ManyToManyField` 字段和反向关联可能有多个关联的行，包含它们可能导致结果集的倍数放大。如果你在 ``values()`` 查询中包含多个这样的字段将更加明显，这种情况下将返回所有可能的组合。

``values_list()``
~~~~~~~~~~~~~~~~~

.. method:: values_list(*fields, flat=False)

与 ``values()`` 类似，只是在迭代时返回的是元组而不是字典。每个元组包含传递给 ``values_list()`` 调用的字段的值 —— 所以第一个元素为第一个字段，以此类推。例如::

    >>> Entry.objects.values_list('id', 'headline')
    [(1, 'First entry'), ...]

如果只传递一个字段，你还可以传递 ``flat`` 参数。如果为 ``True``，它表示返回的结果为单个值而不是元组。一个例子会让它们的区别更加清晰::

    >>> Entry.objects.values_list('id').order_by('id')
    [(1,), (2,), (3,), ...]

    >>> Entry.objects.values_list('id', flat=True).order_by('id')
    [1, 2, 3, ...]

如果有多个字段，传递 ``flat`` 将发生错误。

如果你不传递任何值给 ``values_list()``，它将返回模型中的所有字段，以它们在模型中定义的顺序。

常见的需求是获取某个模型实例的特定字段值。要实现这一点，使用 ``values_list()`` 后面跟一个 ``get()`` 调用::

    >>> Entry.objects.values_list('headline', flat=True).get(pk=1)
    'First entry'

``values()`` 和 ``values_list()`` 旨在作为特定用例的优化：检索数据子集，而无需创建模型实例的开销。当处理多对多和其他多值关系（例如反向外键的一对多关系）时，这个隐喻土崩瓦解，因为“一行一个对象”假设不成立。

例如，注意在跨 :class:`~django.db.models.ManyToManyField` 查询时的行为::

    >>> Author.objects.values_list('name', 'entry__headline')
    [('Noam Chomsky', 'Impressions of Gaza'),
     ('George Orwell', 'Why Socialists Do Not Believe in Fun'),
     ('George Orwell', 'In Defence of English Cooking'),
     ('Don Quixote', None)]

具有多个条目的作者多次出现，没有任何条目的作者的条目标题为 ``None``。

类似地，当查询反向外键时，对于没有任何作者的条目，出现 ``None``::

    >>> Entry.objects.values_list('authors')
    [('Noam Chomsky',), ('George Orwell',), (None,)]

``dates()``
~~~~~~~~~~~

.. method:: dates(field, kind, order='ASC')

返回一个 ``QuerySet``，其计算结果为 :class:`datetime.date` 对象列表，表示特定种类的所有可用日期 ``QuerySet``。

``field`` 应为模型的 ``DateField`` 的名称。``kind`` 应为 ``"year"``、``"month"`` 或 ``"day"``。Each
``datetime.date`` object in the result list is "truncated" to the given
``type``.

* ``"year"`` 返回对应该 field 的所有不同年份值的 list。
* ``"month"`` 返回字段的所有不同年/月值的列表。
* ``"day"`` 返回字段的所有不同年/月/日值的列表。

``order``，默认为 ``'ASC'``，可选项为 ``'ASC'`` 或 ``'DESC'``。这个选项指定了返回结果的排序方式。

例子::

    >>> Entry.objects.dates('pub_date', 'year')
    [datetime.date(2005, 1, 1)]
    >>> Entry.objects.dates('pub_date', 'month')
    [datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
    >>> Entry.objects.dates('pub_date', 'day')
    [datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
    >>> Entry.objects.dates('pub_date', 'day', order='DESC')
    [datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
    >>> Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
    [datetime.date(2005, 3, 20)]

``datetimes()``
~~~~~~~~~~~~~~~

.. method:: datetimes(field_name, kind, order='ASC', tzinfo=None)

返回 ``QuerySet``，其计算为 :class:`datetime.datetime` 对象的列表，表示 ``QuerySet`` 内容中特定种类的所有可用日期。

``field_name`` 应为模型的 ``DateTimeField`` 的名称。

``kind`` 应为 ``"year"``、``"month"``、``"day"``、``"hour"``、``"minute"`` 或 ``"second"``。结果列表中的每个 ``datetime.datetime`` 对象被“截断”到给定的 ``类型``。

``order``，默认为 ``'ASC'``，可选项为 ``'ASC'`` 或 ``'DESC'``。这个选项指定了返回结果的排序方式。

``tzinfo`` 定义在截断之前将数据时间转换到的时区。实际上，给定的 datetime 具有不同的表示，这取决于使用的时区。此参数必须是 :class:`datetime.tzinfo` 对象。如果它是 ``None``，Django 使用 :ref:`当前时区 <default-current-time-zone>`。当 :setting:`USE_TZ` 为 ``False`` 时，它不起作用。

.. _database-time-zone-definitions:

.. note::

    此函数直接在数据库中执行时区转换。因此，您的数据库必须能够解释 ``tzinfo.tzname(None)`` 的值。这转化为以下要求:

    - SQLite：安装 pytz_ —— 转换实际上是在 Python 中执行的。
    - PostgreSQL：没有要求（见 `Time Zones`_）。
    - Oracle：无要求（请参阅 `Choosing a Time Zone File`_）。
    - MySQL：安装 pytz_ ，并使用 `mysql_tzinfo_to_sql`_ 加载时区表。

    .. _pytz: http://pytz.sourceforge.net/
    .. _Time Zones: https://www.postgresql.org/docs/current/static/datatype-datetime.html#DATATYPE-TIMEZONES
    .. _Choosing a Time Zone File: https://docs.oracle.com/cd/E11882_01/server.112/e10729/ch4datetime.htm#NLSPG258
    .. _mysql_tzinfo_to_sql: https://dev.mysql.com/doc/refman/en/mysql-tzinfo-to-sql.html

``none()``
~~~~~~~~~~

.. method:: none()

调用 none() 将创建一个从不返回任何对象的 queryset，并且在访问结果时不会执行任何查询。qs.none() 查询集是 ``EmptyQuerySet`` 的一个实例。

例子::

    >>> Entry.objects.none()
    <QuerySet []>
    >>> from django.db.models.query import EmptyQuerySet
    >>> isinstance(Entry.objects.none(), EmptyQuerySet)
    True

``all()``
~~~~~~~~~

.. method:: all()

返回当前 ``QuerySet`` （或子类）的 *副本*。它可以用于在你希望传递一个模型管理器或 ``QuerySet`` 并对结果做进一步过滤的情况。不管对哪一种对象调用 ``all()``，你都将获得一个可以工作的 ``QuerySet``。

当对 ``QuerySet`` 进行 :ref:`求值 <when-querysets-are-evaluated>` 时，它通常会缓存其结果。如果数据库中的数据在 ``QuerySet`` 求值之后可能已经改变，你可以通过在以前求值过的 ``QuerySet`` 上调用相同的 ``all()`` 查询以获得更新后的结果。

``select_related()``
~~~~~~~~~~~~~~~~~~~~

.. method:: select_related(*fields)

返回一个 ``QuerySet``，当执行它的查询时它沿着外键关系查询关联的对象的数据。它会生成一个复杂的查询并引起性能的损耗，但是在以后使用外键关系时将不需要数据库查询。

下面的例子解释了普通查询和 ``select_related()`` 查询的区别。下面是一个标准的查询::

    # Hits the database.
    e = Entry.objects.get(id=5)

    # Hits the database again to get the related Blog object.
    b = e.blog

下面是一个 ``select_related`` 查询::

    # Hits the database.
    e = Entry.objects.select_related('blog').get(id=5)

    # Doesn't hit the database, because e.blog has been prepopulated
    # in the previous query.
    b = e.blog

``select_related()`` 可用于任何对象的 queryset::

    from django.utils import timezone

    # Find all the blogs with entries scheduled to be published in the future.
    blogs = set()

    for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog'):
        # Without select_related(), this would make a database query for each
        # loop iteration in order to fetch the related blog for each entry.
        blogs.add(e.blog)

``filter()`` 和 ``select_related()`` 链的顺序不重要。下面的查询集是等同的::

    Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
    Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())

你可以沿着外键查询。如果你有以下模型::

    from django.db import models

    class City(models.Model):
        # ...
        pass

    class Person(models.Model):
        # ...
        hometown = models.ForeignKey(
            City,
            on_delete=models.SET_NULL,
            blank=True,
            null=True,
        )

    class Book(models.Model):
        # ...
        author = models.ForeignKey(Person, on_delete=models.CASCADE)

... 那么 ``Book.objects.select_related('author__hometown').get(id=4)`` 调用将缓存关联的 ``Person`` *和* 关联的 ``City``::

    b = Book.objects.select_related('author__hometown').get(id=4)
    p = b.author         # Doesn't hit the database.
    c = p.hometown       # Doesn't hit the database.

    b = Book.objects.get(id=4) # No select_related() in this example.
    p = b.author         # Hits the database.
    c = p.hometown       # Hits the database.

在传递给 ``select_related()`` 的字段中，你可以使用任何 :class:`~django.db.models.ForeignKey` 和
:class:`~django.db.models.OneToOneField`。

在传递给 ``select_related`` 的字段中，你还可以反向引用 :class:`~django.db.models.OneToOneField` —— 也就是说，你可以回溯到定义 :class:`~django.db.models.OneToOneField` 的字段。此时，可以使用关联对象字段的 :attr:`related_name
<django.db.models.ForeignKey.related_name>`，而不要指定字段的名称。

有些情况下，你希望对很多对象调用 ``select_related()``，或者你不知道所有的关联关系。在这些情况下，可以调用不带参数的 ``select_related()`` 它将查找能找到的所有不可为空外键 —— 可以为空的外键必须明确指定。大部分情况下不建议这样做，因为它会使得底层的查询非常复杂并且返回的很多数据都不是真实需要的。

如果你需要清除 ``QuerySet`` 上以前的 ``select_related`` 添加的关联字段，可以传递一个 ``None`` 作为参数::

   >>> without_relations = queryset.select_related(None)

链式调用 ``select_related`` 的工作方式与其它方法类似 —— 也就是说，``select_related('foo', 'bar')`` 等同于 ``select_related('foo').select_related('bar')``。

``prefetch_related()``
~~~~~~~~~~~~~~~~~~~~~~

.. method:: prefetch_related(*lookups)

返回 ``QuerySet``，它将在单个批处理中自动检索每个指定查找的相关对象。

这具有与 ``select_related`` 类似的目的，两者都被设计为阻止由访问相关对象而导致的数据库查询的泛滥，但是策略是完全不同的。

``select_related`` 通过创建 SQL 连接并在 ``SELECT`` 语句中包括相关对象的字段来工作。因此，``select_related`` 在同一数据库查询中获取相关对象。然而，为了避免由于跨越“多个”关系而导致的大得多的结果集，``select_related`` 限于单值关系 —— 外键和一对一关系。

``prefetch_related``，另一方面，为每个关系单独查找，并在 Python 中“加入”。这允许它预取多对多和多对一对象，除了外键和一对一关系，它们不能使用 ``select_related`` 来完成。``select_related``。它还支持 :class:`~django.contrib.contenttypes.fields.GenericRelation` 和 :class:`~django.contrib.contenttypes.fields.GenericForeignKey` 的预取。然而，它必须限于一组同样的结果。 例如，仅当查询限于一个 ``ContentType`` 时，才支持预取由 ``GenericForeignKey`` 引用的对象。

例如，假设您有这些模型::

    from django.db import models

    class Topping(models.Model):
        name = models.CharField(max_length=30)

    class Pizza(models.Model):
        name = models.CharField(max_length=50)
        toppings = models.ManyToManyField(Topping)

        def __str__(self):              # __unicode__ on Python 2
            return "%s (%s)" % (
                self.name,
                ", ".join(topping.name for topping in self.toppings.all()),
            )

并运行::

    >>> Pizza.objects.all()
    ["Hawaiian (ham, pineapple)", "Seafood (prawns, smoked salmon)"...

问题是每次 ``Pizza.__str__()`` 要求 ``self.toppings.all()`` 它必须查询数据库，因此 ``Pizza.objects.all()`` 将在 Pizza ``QuerySet`` 中的 **每个** 项目的 Toppings 表上运行查询。

我们可以使用 ``prefetch_related`` 减少为只有两个查询：

    >>> Pizza.objects.all().prefetch_related('toppings')

这意味着检索到的每个 ``Pizza`` 都会执行 ``self.toppings.all()``；现在每次调用 ``self.toppings.all()``，而不是去数据库的项目，它会在预取的 ``QuerySet`` 缓存中找到它们填充在单个查询中。

也就是说，所有相关的配料将在单个查询中提取，并用于使具有相关结果的预填充缓存的 ``QuerySet``；这些 ``QuerySet`` 然后在 ``self.toppings.all()`` 调用中使用。

``prefetch_related()`` 中的附加查询在 ``QuerySet`` 开始计算并且主查询已执行后执行。

如果您有可迭代的模型实例，则可以使用 :func:`~django.db.models.prefetch_related_objects` 函数在这些实例上预取相关属性。

请注意，主要 ``QuerySet`` 的结果缓存和所有指定的相关对象将被完全加载到内存中。这改变了 ``QuerySet`` 的典型行为，通常尽量避免在需要之前将所有对象加载到内存中，即使在数据库中执行了查询之后。

.. note::

    请记住，与 ``QuerySet`` 一样，任何后续的链接方法隐含不同的数据库查询将忽略以前缓存的结果，并使用新的数据库查询检索数据。所以，如果你写下面的话：

        >>> pizzas = Pizza.objects.prefetch_related('toppings')
        >>> [list(pizza.toppings.filter(spicy=True)) for pizza in pizzas]

    ...然后事实，已经预取的 ``pizza.toppings.all()`` 不会帮助你。``prefetch_related('toppings')`` 隐含 ``pizza.toppings.all()``，但 ``pizza.toppings.filter()`` 是一个不同的查询。预取的缓存在这里不能帮助；实际上它伤害性能，因为你做了一个你没有使用的数据库查询。所以使用这个功能小心！

您还可以使用正常连接语法来执行相关字段的相关字段。假设我们有一个额外的模型上面的例子::

    class Restaurant(models.Model):
        pizzas = models.ManyToManyField(Pizza, related_name='restaurants')
        best_pizza = models.ForeignKey(Pizza, related_name='championed_by')

以下都是合法的:

    >>> Restaurant.objects.prefetch_related('pizzas__toppings')

这将预取所有比萨饼属于餐厅，所有浇头属于那些比萨饼。这将导致总共 3 个数据库查询 —— 一个用于餐馆，一个用于比萨饼，一个用于浇头。

    >>> Restaurant.objects.prefetch_related('best_pizza__toppings')

这将获取最好的比萨饼和每个餐厅最好的披萨的所有浇头。这将在 3 个数据库查询 —— 一个为餐厅，一个为“最佳比萨饼”，一个为一个为浇头。

当然，也可以使用 ``select_related`` 来获取 ``best_pizza`` 关系，以将查询计数减少为 2：

    >>> Restaurant.objects.select_related('best_pizza').prefetch_related('best_pizza__toppings')

由于预取在主查询（其包括 ``select_related`` 所需的连接）之后执行，因此它能够检测到 ``best_pizza`` 对象已经被提取，并且请跳过重新获取它们。

链接 ``prefetch_related`` 调用将累积预取的查找。要清除任何 ``prefetch_related`` 行为，请传递 ``None`` 作为参数：

   >>> non_prefetched = qs.prefetch_related(None)

使用 ``prefetch_related`` 时需要注意的一点是，查询创建的对象可以在它们相关的不同对象之间共享，即单个 Python 模型实例可以出现在树中的多个点返回的对象。这通常会与外键关系发生。通常这种行为不会是一个问题，并且实际上会节省内存和 CPU 时间。

虽然 ``prefetch_related`` 支持预取 ``GenericForeignKey`` 关系，但查询的数量将取决于数据。由于 ``GenericForeignKey`` 可以引用多个表中的数据，因此需要对每个引用的表进行一次查询，而不是对所有项进行一次查询。如果尚未提取相关行，则可能会对 ``ContentType`` 表执行其他查询。

``prefetch_related`` 在大多数情况下将使用使用“IN”运算符的 SQL 查询来实现。这意味着对于一个大的 ``QuerySet``，可能会生成一个大的“IN”子句，根据数据库，在解析或执行 SQL 查询时可能会有性能问题。始终为您的使用情况配置文件！

请注意，如果您使用 ``iterator()`` 来运行查询，则会忽略 ``prefetch_related()`` 调用，因为这两个优化并没有意义。

您可以使用 :class:`~django.db.models.Prefetch` 对象进一步控制预取操作。

在其最简单的形式中，``Prefetch`` 等效于传统的基于字符串的查找：

    >>> from django.db.models import Prefetch
    >>> Restaurant.objects.prefetch_related(Prefetch('pizzas__toppings'))

您可以使用可选的 ``queryset`` 参数提供自定义查询集。这可以用于更改查询集的默认顺序：

    >>> Restaurant.objects.prefetch_related(
    ...     Prefetch('pizzas__toppings', queryset=Toppings.objects.order_by('name')))

或者在适当时调用 :meth:`~django.db.models.query.QuerySet.select_related()` 以进一步减少查询数量：

    >>> Pizza.objects.prefetch_related(
    ...     Prefetch('restaurants', queryset=Restaurant.objects.select_related('best_pizza')))

您还可以使用可选的 ``to_attr`` 参数将预取结果分配给自定义属性。结果将直接存储在列表中。

这允许使用不同的 ``QuerySet`` 预取相同的关系多次；例如：

    >>> vegetarian_pizzas = Pizza.objects.filter(vegetarian=True)
    >>> Restaurant.objects.prefetch_related(
    ...     Prefetch('pizzas', to_attr='menu'),
    ...     Prefetch('pizzas', queryset=vegetarian_pizzas, to_attr='vegetarian_menu'))

使用自定义 ``to_attr`` 创建的查找仍然可以像往常一样被其他查找遍历：

    >>> vegetarian_pizzas = Pizza.objects.filter(vegetarian=True)
    >>> Restaurant.objects.prefetch_related(
    ...     Prefetch('pizzas', queryset=vegetarian_pizzas, to_attr='vegetarian_menu'),
    ...     'vegetarian_menu__toppings')

在过滤预取结果时，建议使用 ``to_attr``，因为它比在相关管理器的缓存中存储过滤的结果更不明确：

    >>> queryset = Pizza.objects.filter(vegetarian=True)
    >>>
    >>> # Recommended:
    >>> restaurants = Restaurant.objects.prefetch_related(
    ...     Prefetch('pizzas', queryset=queryset, to_attr='vegetarian_pizzas'))
    >>> vegetarian_pizzas = restaurants[0].vegetarian_pizzas
    >>>
    >>> # Not recommended:
    >>> restaurants = Restaurant.objects.prefetch_related(
    ...     Prefetch('pizzas', queryset=queryset))
    >>> vegetarian_pizzas = restaurants[0].pizzas.all()

自定义预取也适用于单个相关关系，如前面的 ``ForeignKey`` 或 ``OneToOneField``。一般来说，您希望对这些关系使用 :meth:`select_related()` ，但有很多情况下使用自定义 ``QuerySet`` 进行预取是有用的：

* 您想要使用在相关模型上执行进一步预取的 ``QuerySet``。

* 您希望仅预取相关对象的子集。

* 您想要使用 :meth:`延迟字段 <defer()>` 等性能优化技术：

    >>> queryset = Pizza.objects.only('name')
    >>>
    >>> restaurants = Restaurant.objects.prefetch_related(
    ...     Prefetch('best_pizza', queryset=queryset))

.. note::

    查找的顺序很重要。

    请看下面的例子：

       >>> prefetch_related('pizzas__toppings', 'pizzas')

    即使它是无序的，因为 ``'pizzas__toppings'`` 已经包含所有需要的信息，因此第二个参数 ``'pizzas'`` 实际上是多余的。

        >>> prefetch_related('pizzas__toppings', Prefetch('pizzas', queryset=Pizza.objects.all()))

    这将引发 ``ValueError``，因为尝试重新定义先前查看的查询的 queryset。请注意，创建了隐式 queryset，以作为 ``'pizzas__toppings'`` 查找的一部分遍历 ``'pizzas'``。

        >>> prefetch_related('pizza_list__toppings', Prefetch('pizzas', to_attr='pizza_list'))

    这会触发 ``AttributeError``，因为 ``'pizza_list'`` 在处理 ``'pizza_list__toppings'`` 时不存在。

    这种考虑不限于使用 ``Prefetch`` 对象。一些高级技术可能需要以特定顺序执行查找以避免创建额外的查询；因此建议始终仔细排列 ``prefetch_related`` 参数。

``extra()``
~~~~~~~~~~~

.. method:: extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)

有些情况下，Django 的查询语法难以简单的表达复杂的 ``WHERE`` 子句，对于这种情况, Django 提供了 ``extra()`` ``QuerySet`` 修改机制 —— 它能在 ``QuerySet`` 生成的 SQL 从句中注入新子句。

.. admonition:: 使用此方法作为最后手段

    这是一个旧的 API，我们的打算在将来的某个时候弃用。
    仅当您无法使用其他查询集方法表达查询时，才使用它。
    如果你确实需要使用它，请使用 `QuerySet.extra 关键字 <https://code.djangoproject.com/query?status=assigned&status=new&keywords=~QuerySet.extra>`_ 以你的用例 `提一个 Ticket <https://code.djangoproject.com/newticket>`_ （请首先检查现有的 Ticket 列表），以便我们可以增强 QuerySet API 直到允许删除 ``extra()``。我们不再改进或修复此方法的错误。

    例如，这样使用 ``extra()``::

        >>> qs.extra(
        ...     select={'val': "select col from sometable where othercol = %s"},
        ...     select_params=(someparam,),
        ... )

    等价于::

        >>> qs.annotate(val=RawSQL("select col from sometable where othercol = %s", (someparam,)))

    使用 :class:`~django.db.models.expressions.RawSQL` 的主要好处是，如果需要你可以设置 ``output_field``。主要缺点是，如果你引用原始 SQL 中查询集的某些表别名，那么 Django 可能会更改该别名（例如，当查询集在另一个查询中用作子查询时）。

.. warning::

    无论何时你都需要非常小心的使用 ``extra()``。每次使用它时，您都应该转义用户可以使用 ``params`` 控制的任何参数，以防止 SQL 注入攻击。请详细了解 :ref:`SQL 注入保护 <sql-injection-protection>`。

由于产品差异的原因，这些自定义的查询难以保障在不同的数据库之间兼容（因为你手写 SQL 代码的原因），而且违背了 DRY 原则，所以如非必要，还是尽量避免使用它。

可以指定一个或多个 ``params``、``select``、``where`` 或者 ``tables``。这些参数都不是必须的，但是你至少要使用一个。

* ``select``

  ``select`` 参数可以让你在 ``SELECT`` 从句中添加其他字段信息，它应该是一个字典，存放着属性名到 SQL 从句的映射。

  例如::

      Entry.objects.extra(select={'is_recent': "pub_date > '2006-01-01'"})

  结果集中每个 ``Entry`` 对象都有一个额外的属性  ``is_recent``，它是一个布尔值，表示 Entry 对象的 ``pub_date`` 是否晚于 2006 年 1 月 1 日。

  Django 会直接在 ``SELECT`` 中加入对应的 SQL 片断，所以转换后的 SQL 如下::

      SELECT blog_entry.*, (pub_date > '2006-01-01') AS is_recent
      FROM blog_entry;


  下面这个例子更复杂一些；它会在每个 ``Blog`` 对象中添加一个 ``entry_count`` 属性，它会运行一个子查询，得到相关联的 ``Entry`` 对象的数量::

      Blog.objects.extra(
          select={
              'entry_count': 'SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id'
          },
      )

  在上面这个特例中，我们要了解这个事实，就是 ``blog_blog`` 表已经存在于 ``FROM`` 从句中。

  上面例子的结果 SQL 将是::

      SELECT blog_blog.*, (SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id) AS entry_count
      FROM blog_blog;

  要注意的是，大多数数据库需要在子句两端添加括号，而在 Django 的 ``select`` 从句中却无须这样。另请注意，某些数据库后端（如某些 MySQL 版本）不支持子查询。

  在少数情况下，您可能希望将参数传递到 ``extra(select=...)`` 中的SQL片段。为此，请使用 ``select_params`` 参数。由于 ``select_params`` 是一个序列，并且 ``select`` 属性是字典，因此需要注意，以便参数与额外的选择片段正确匹配。在这种情况下，您应该使用 :class:`collections.OrderedDict` 用于 ``select`` 值，而不仅仅是一个普通的 Python 字典。

  这将工作，例如::

      Blog.objects.extra(
          select=OrderedDict([('a', '%s'), ('b', '%s')]),
          select_params=('one', 'two'))

  如果您需要在选择字符串中使用文本 ``%s``，请使用序列 ``%%s``。

* ``where`` / ``tables``

  您可以使用 ``where`` 定义显式 SQL ``WHERE`` 子句 —— 也许执行非显式连接。您可以使用 ``tables`` 手动将表添加到 SQL ``FROM`` 子句。

  ``where`` 和 ``tables`` 都接受字符串列表。所有 ``where`` 参数均为“AND”任何其他搜索条件。

  例如::

      Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])

  ...翻译（大致）为以下 SQL::

      SELECT * FROM blog_entry WHERE (foo='a' OR bar='a') AND (baz='a')

  如果您要指定已在查询中使用的表，请在使用 ``tables`` 参数时小心。当您通过 ``tables`` 参数添加额外的表时，Django 假定您希望该表包含额外的时间（如果已包括）。这会产生一个问题，因为表名将会被赋予一个别名。如果表在 SQL 语句中多次出现，则第二次和后续出现必须使用别名，以便数据库可以区分它们。如果您指的是在额外的 ``where`` 参数中添加的额外表，这将导致错误。

  通常，您只需添加尚未显示在查询中的额外表。然而，如果发生上述情况，则有几种解决方案。首先，看看你是否可以不包括额外的表，并使用已经在查询中的一个。如果不可能，请将 ``extra()`` 调用放在查询集结构的前面，以便您的表是该表的第一次使用。最后，如果所有其他失败，请查看生成的查询并重写 ``where`` 添加以使用给您的额外表的别名。每次以相同的方式构造查询集时，别名将是相同的，因此您可以依靠别名不更改。

* ``order_by``

  如果您需要使用通过 ``extra()`` 包含的一些新字段或表来对结果查询进行排序，请使用 ``order_by`` 参数 ``extra()`` 这些字符串应该是模型字段（如查询集上的正常 :meth:`order_by()` 方法），形式为 ``table_name.column_name`` 或您在 ``select`` 参数到 ``extra()``。

  例如::

      q = Entry.objects.extra(select={'is_recent': "pub_date > '2006-01-01'"})
      q = q.extra(order_by = ['-is_recent'])

  这会将 ``is_recent`` 的所有项目排序到结果集的前面（``True`` 在 ``False`` 之前按降序排序）。

  顺便说一句，你可以对 ``extra()`` 进行多次调用，它会按照你的期望（每次添加新的约束）运行。

* ``params``

  上述 ``where`` 参数可以使用标准 Python 数据库字符串占位 —— ``'%s'`` 来指示数据库引擎应自动引用的参数。``params`` 参数是要替换的任何额外参数的列表。

  例如::

      Entry.objects.extra(where=['headline=%s'], params=['Lennon'])

  始终使用 ``params`` 而不是将值直接嵌入 ``where``，因为 ``params`` 会确保根据您的特定后端正确引用值。例如，引号将被正确转义。

  坏::

      Entry.objects.extra(where=["headline='Lennon'"])

  好::

      Entry.objects.extra(where=['headline=%s'], params=['Lennon'])

.. warning::

    如果您正在对 MySQL 执行查询，请注意，MySQL 的静默类型强制可能会在混合类型时导致意外的结果。如果查询字符串类型列，但使用整数值，MySQL 将在执行比较之前将表中所有值的类型强制为整数。例如，如果表包含值 ``'abc'``，``'def'`` 并查询 ``WHERE mycolumn=0``，两行都将匹配。为了防止这种情况，请在使用查询中的值之前执行正确的类型转换。

``defer()``
~~~~~~~~~~~

.. method:: defer(*fields)

在一些复杂的数据建模情况下，您的模型可能包含大量字段，其中一些可能包含大量数据（例如，文本字段），或者需要昂贵的处理来将它们转换为 Python 对象。如果您在某些情况下使用查询集的结果，当您最初获取数据时不知道是否需要这些特定字段，可以告诉 Django 不要从数据库中检索它们。

这是通过传递字段名称不加载到 ``defer()``::

    Entry.objects.defer("headline", "body")

具有延迟字段的查询集仍将返回模型实例。如果您访问该字段（一次一个，而不是一次所有的延迟字段），将从数据库中检索每个延迟字段。

您可以多次调用 ``defer()``。每个调用都向延迟集添加新字段::

    # Defers both the body and headline fields.
    Entry.objects.defer("body").filter(rating=5).defer("headline")

字段添加到延迟集的顺序无关紧要。调用具有已延迟的字段名称的 ``defer()`` 是无害的（该字段仍将被延迟）。

您可以使用标准的双下划线符号来分隔相关字段，从而推迟相关模型中的字段加载（如果相关模型通过 :meth:`select_related()`) 加载）::

    Blog.objects.select_related().defer("entry__headline", "entry__body")

如果要清除延迟字段集，请将 ``None`` 作为参数传递到 ``defer()``::

    # Load all fields immediately.
    my_queryset.defer(None)

模型中的某些字段不会被延迟，即使您要求它们。你永远不能推迟加载主键。如果您使用 :meth:`select_related()` 检索相关模型，则不应推迟从主模型连接到相关模型的字段的加载，否则将导致错误。

.. note::

    ``defer()`` 方法（及其表兄弟，:meth:`only()`）仅适用于高级用例。他们在你仔细分析查询并准确的理解并判断过哪些信息是你需要的时提供优化，返回所需字段和模型的完整字段之间的区别将是显著的。

    即使你认为你是在高级用例的情况下， **当你不能在查询集加载时确定是否需要额外的字段时，只使用 defer()** 如果您经常加载和使用特定的数据子集，最好的选择是规范化模型，并将未加载的数据放入单独的模型（和数据库表）。如果列 *必须* 由于某种原因保留在一个表中，请创建一个具有 ``Meta.managed = False`` （请参阅 :attr:`managed attribute <django.db.models.Options.managed>` 文档），只包含您通常需要加载和使用的字段否则调用 ``defer()``。这使得你的代码对读者更加明确，稍微更快一些，并且在 Python 进程中消耗更少的内存。

    例如，这两个模型使用相同的底层数据库表::

        class CommonlyUsedModel(models.Model):
            f1 = models.CharField(max_length=10)

            class Meta:
                managed = False
                db_table = 'app_largetable'

        class ManagedModel(models.Model):
            f1 = models.CharField(max_length=10)
            f2 = models.CharField(max_length=10)

            class Meta:
                db_table = 'app_largetable'

        # Two equivalent QuerySets:
        CommonlyUsedModel.objects.all()
        ManagedModel.objects.all().defer('f2')

    如果许多字段需要在非托管模型中复制，最好使用共享字段创建抽象模型，然后使非托管模型和托管模型从抽象模型继承。

.. note::

    当对具有延迟字段的实例调用 :meth:`~django.db.models.Model.save()` 时，仅保存加载的字段。有关详细信息，请参见 :meth:`~django.db.models.Model.save()`。

``only()``
~~~~~~~~~~

.. method:: only(*fields)

``only()`` 方法或多或少与 :meth:`defer()` 相反。您调用它时，应该在检索模型时延迟的字段。如果你有一个模型几乎所有的字段需要延迟，使用 ``only()`` 指定补充的字段集可以导致更简单的代码。

假设您有一个包含字段 ``name``、``age`` 和 ``biography`` 的模型。就延迟字段而言，以下两个查询集是相同的::

    Person.objects.defer("age", "biography")
    Person.objects.only("name")

每当您调用 ``only()`` 时，*replaces* 立即加载的字段集。方法的名称是助记符： **只有** 这些字段立即加载；其余的都被推迟。因此，对 ``only()`` 的连续调用仅导致所考虑的最后字段::

    # This will defer all fields except the headline.
    Entry.objects.only("body", "rating").only("headline")

由于 ``defer()`` 以递增方式动作（向延迟列表中添加字段），因此您可以将调用结合到 ``only()`` 和 ``defer()``::

    # Final result is that everything except "headline" is deferred.
    Entry.objects.only("headline", "body").defer("body")

    # Final result loads headline and body immediately (only() replaces any
    # existing set of fields).
    Entry.objects.defer("body").only("headline", "body")

:meth:`defer` 文档中的所有注意事项也适用于 ``only()``。当你没有其它选择时谨慎地使用它。

使用 :meth:`only` 并省略使用 :meth:`select_related` 请求的字段也是错误。

.. note::

    当对具有延迟字段的实例调用 :meth:`~django.db.models.Model.save()` 时，仅保存加载的字段。有关详细信息，请参见 :meth:`~django.db.models.Model.save()`。

``using()``
~~~~~~~~~~~

.. method:: using(alias)

如果你使用多个数据库，这个方法用于控制 ``QuerySet`` 将在哪个数据库上求值。这个方法的唯一参数是数据库的别名，定义在 :setting:`DATABASES`。

例如::

    # queries the database with the 'default' alias.
    >>> Entry.objects.all()

    # queries the database with the 'backup' alias
    >>> Entry.objects.using('backup')

``select_for_update()``
~~~~~~~~~~~~~~~~~~~~~~~

.. method:: select_for_update(nowait=False)

返回一个查询集，会锁定相关行直到事务结束。在支持的数据库上面产生一个 ``SELECT ... FOR UPDATE`` 语句。

例如::

    entries = Entry.objects.select_for_update().filter(author=request.user)

所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改。

一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。如果这不是你想要的行为，请使用 ``select_for_update(nowait=True)``。这将使查询不阻塞。如果其它事务持有冲突的锁, 那么查询将引发 :exc:`~django.db.DatabaseError` 异常。

目前 ``postgresql``，``oracle`` 和 ``mysql`` 数据库后端 ``select_for_update()``。但是 MySQL 不支持 ``nowait`` 参数。显然，用户应该检查后端的支持情况。

当在不支持 ``nowait`` 功能的数据库后端（例如 MySQL）使用 ``nowait=True`` 参数调用 ``select_for_update()`` 时将抛出 :exc:`~django.db.DatabaseError` 异常。这是防止意外造成代码被阻塞。

对于支持 ``SELECT ... FOR UPDATE`` 的后端在自动提交模式下使用 ``select_for_update()`` 对查询集求值将抛出 :exc:`~django.db.transaction.TransactionManagementError` 异常，原因是自动提交模式下不支持锁定行。如果允许这个调用，那么可能造成数据损坏，而且这个功能很容易在事务外被调用。

对于不支持 ``SELECT ... FOR UPDATE`` 的后端（例如 SQLite）``select_for_update()`` 将没有效果。如果在自动提交模式下使用 ``select_for_update()``，``SELECT ... FOR UPDATE`` 将不会添加到查询，并且不会抛出异常。

.. warning::

    虽然 ``select_for_update()`` 通常在自动提交模式下失败，因为 :class:`~django.test.TestCase` 在一个事务中自动包装每个测试，在 ``TestCase`` 甚至在 :func:`~django.db.transaction.atomic()` 块之外调用 ``select_for_update()`` 将会（可能意外）通过而不会抛出一个 ``TransactionManagementError`` 异常。要正确测试 ``select_for_update()`` 你应该使用 :class:`~django.test.TransactionTestCase`。

``raw()``
~~~~~~~~~

.. method:: raw(raw_query, params=None, translations=None)

接收一个原始的 SQL 查询，执行它并返回一个 ``django.db.models.query.RawQuerySet`` 实例。这个 ``RawQuerySet`` 实例可以迭代以提供实例对象，就像普通的 ``QuerySet`` 一样。

更多信息参见 :doc:`/topics/db/sql`。

.. warning::

  ``raw()`` 永远触发一个新的查询，而与之前的过滤无关。因此，它通常应该从 ``Manager`` 或一个全新的 ``QuerySet`` 实例调用。

不会返回 ``QuerySet`` 的方法
-----------------------------------------

以下 ``QuerySet`` 方法对 ``QuerySet`` 求值并返回一些 *不是* ``QuerySet`` 的东西。

这些方法不使用高速缓存（请参阅 :ref:`caching-and-querysets`）。这些方法每次被调用的时候都会查询数据库。

``get()``
~~~~~~~~~

.. method:: get(**kwargs)

返回按照查询参数匹配到的对象，参数的格式应该符合 `Field 查找`_ 的要求。

如果匹配到的对象个数不只一个的话，``get()`` 将抛出 :exc:`~django.core.exceptions.MultipleObjectsReturned` 异常。:exc:`~django.core.exceptions.MultipleObjectsReturned` 异常是模型类的属性。

如果根据给出的参数匹配不到对象的话，``get()`` 将抛出 :exc:`~django.db.models.Model.DoesNotExist` 异常。这个异常是模型类的属性。例 ::

    Entry.objects.get(id='foo') # raises Entry.DoesNotExist

:exc:`~django.db.models.Model.DoesNotExist` 异常从 :exc:`django.core.exceptions.ObjectDoesNotExist` 继承，因此您可以定位多个 :exc:`~django.db.models.Model.DoesNotExist` 异常。例如::

    from django.core.exceptions import ObjectDoesNotExist
    try:
        e = Entry.objects.get(id=3)
        b = Blog.objects.get(id=1)
    except ObjectDoesNotExist:
        print("Either the entry or blog doesn't exist.")

如果你期望一个查询集返回一行，你可以使用不带任何参数的 ``get()`` 来返回哪一行的对象::

    entry = Entry.objects.filter(...).exclude(...).get()

``create()``
~~~~~~~~~~~~

.. method:: create(**kwargs)

一个在一步操作中同时创建对象并且保存的便捷方法。所以::

    p = Person.objects.create(first_name="Bruce", last_name="Springsteen")

和::

    p = Person(first_name="Bruce", last_name="Springsteen")
    p.save(force_insert=True)

是等同的。

参数 :ref:`force_insert <ref-models-force-insert>` 在其他的文档中有介绍，它意味着一个新的对象一定会被创建。正常情况下，你不必要担心这点。然而，如果你的模型中有一个你手动设置主键，并且这个值已经存在于数据库中，调用 ``create()`` 将会失败并且抛出 :exc:`~django.db.IntegrityError` 因为主键必须是唯一的。如果你手动设置了主键，做好异常处理的准备。

``get_or_create()``
~~~~~~~~~~~~~~~~~~~

.. method:: get_or_create(defaults=None, **kwargs)

一个通过给出的 ``kwargs`` 来查询对象的便捷方法（如果你的模型中的所有字段都有默认值，可以留空），需要的话创建一个对象。

返回一个由 ``(object, created)`` 组成的元组，元组中的 ``object`` 是一个查询到的或者是被创建的对象，``created`` 是一个表示是否创建了新的对象的布尔值。

这主要用作样板代码的一种快捷方式。例如::

    try:
        obj = Person.objects.get(first_name='John', last_name='Lennon')
    except Person.DoesNotExist:
        obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
        obj.save()

如果模型的字段数量较大的话，这种模式就变的非常不易用了。上面的示例可以用 ``get_or_create()`` 重写::

    obj, created = Person.objects.get_or_create(
        first_name='John',
        last_name='Lennon',
        defaults={'birthday': date(1940, 10, 9)},
    )

任何传递给 ``get_or_create()`` 的关键字参数 —— *除了* 一个可选的 ``defaults`` —— 都将传递给 :meth:`get()` 调用。如果查找到一个对象，``get_or_create()`` 返回一个包含匹配到的对象以及 ``False`` 组成的元组。如果查找到的对象超过一个以上，``get_or_create`` 将抛出 :exc:`~django.core.exceptions.MultipleObjectsReturned`。如果查找 *不到* 对象，``get_or_create()`` 将会实例化并保存一个新的对象，返回一个由新的对象以及 ``True`` 组成的元组。新的对象将会大概按照以下的逻辑创建::

    params = {k: v for k, v in kwargs.items() if '__' not in k}
    params.update(defaults)
    obj = self.model(**params)
    obj.save()

它表示从非``'defaults'`` 且不包含双下划线的关键字参数开始（暗示这是一个不精确的查询）。然后将 ``defaults`` 的内容添加进来，覆盖必要的键，并使用结果作为关键字参数传递给模型类。这是对用到的算法的简单描述，但它包含了所有的相关的细节。内部的实现有更多的错误检查并处理一些边缘条件；如果感兴趣，请阅读代码。

如果你有一个名为 ``defaults`` 的字段，并且想在 ``get_or_create()`` 里用它作为精确查询，只需要使用 ``'defaults__exact'``，像这样::

    Foo.objects.get_or_create(defaults__exact='bar', defaults={'defaults': 'baz'})

当你使用手动指定的主键时，``get_or_create()`` 方法与 :meth:`create()` 方法有相似的错误行为 。如果需要创建一个对象而该对象的主键早已存在于数据库中，:exc:`~django.db.IntegrityError` 异常将会被抛出。

这个方法假设正确使用原子操作，正确的数据库配置和底层数据库的正确行为。然而，如果数据库级别没有对 ``get_or_create`` 中用到的 ``kwargs`` 强制要求唯一性（参见 :attr:`~django.db.models.Field.unique` 或 :attr:`~django.db.models.Options.unique_together`），这个方法容易导致紊乱情况，可能会将具有相同参数的多行同时插入。

如果你正在使用 MySQL，请确保使用 ``READ COMMITTED`` 隔离级别而不是 ``REPEATABLE READ``（默认），否则你将会遇到 ``get_or_create`` 抛出 :exc:`~django.db.IntegrityError` 但对象在接下来的 :meth:`~django.db.models.query.QuerySet.get` 调用中并不存在的情况。

最后讲一句 ``get_or_create()`` 在 Django 视图中的使用。请确保只在 ``POST`` 请求中使用，除非你有充分的理由。``GET`` 请求不应该对数据有任何影响。而 ``POST`` 则用于对数据产生影响的请求。更多信息，参见 HTTP 细则中的 :rfc:`安全的方法 <7231#section-4.2.1>`。

.. warning::

  你可以通过 :class:`~django.db.models.ManyToManyField` 属性和反向关联使用 ``get_or_create()``。在这种情况下，你应该限制查询在关联的上下文内部。如果你不一致地使用它，将可能导致完整性问题。

  根据下面的模型::

      class Chapter(models.Model):
          title = models.CharField(max_length=255, unique=True)

      class Book(models.Model):
          title = models.CharField(max_length=256)
          chapters = models.ManyToManyField(Chapter)

  你可以通过 ``Book`` 的 ``chapters`` 字段使用 ``get_or_create()``，但是它只会获取该 ``Book`` 内部的上下文::

      >>> book = Book.objects.create(title="Ulysses")
      >>> book.chapters.get_or_create(title="Telemachus")
      (<Chapter: Telemachus>, True)
      >>> book.chapters.get_or_create(title="Telemachus")
      (<Chapter: Telemachus>, False)
      >>> Chapter.objects.create(title="Chapter 1")
      <Chapter: Chapter 1>
      >>> book.chapters.get_or_create(title="Chapter 1")
      # Raises IntegrityError

  发生这个错误时因为它尝试通过 ``Book "Ulysses"`` 获取或者创建``"Chapter 1"``，但是它不能：关联关系不能获取这个 ``chapter`` 因为它与这个 ``Book`` 不关联，但因为 ``title`` 字段是唯一的它仍然不能创建。

``update_or_create()``
~~~~~~~~~~~~~~~~~~~~~~

.. method:: update_or_create(defaults=None, **kwargs)

一个通过给出的 ``kwargs`` 来更新对象的便捷方法， 如果需要的话创建一个新的对象。``defaults`` 是一个由 (field, value) 对组成的字典，用于更新对象。

返回一个由 ``(object, created)`` 组成的元组，元组中的 ``object`` 是一个创建的或者是被更新的对象，``created`` 是一个标示是否创建了新的对象的布尔值。

``update_or_create`` 方法尝试通过给出的 ``kwargs`` 去从数据库中获取匹配的对象。如果找到匹配的对象，它将会依据 ``defaults`` 字典给出的值更新字段。

这用作样板代码的一种快捷方式。例如::

    defaults = {'first_name': 'Bob'}
    try:
        obj = Person.objects.get(first_name='John', last_name='Lennon')
        for key, value in defaults.items():
            setattr(obj, key, value)
        obj.save()
    except Person.DoesNotExist:
        new_values = {'first_name': 'John', 'last_name': 'Lennon'}
        new_values.update(defaults)
        obj = Person(**new_values)
        obj.save()

如果模型的字段数量较大的话，这种模式就变的非常不易用。上面的示例可以用 ``update_or_create()`` 重写::

    obj, created = Person.objects.update_or_create(
        first_name='John', last_name='Lennon',
        defaults={'first_name': 'Bob'},
    )

``kwargs`` 中的名称如何解析的详细描述可以参见 :meth:`get_or_create`.

和上文描述的 :meth:`get_or_create` 一样，这种方式容易导致紊乱情况，如果数据库层级没有前置唯一性它会让多行同时插入。

``bulk_create()``
~~~~~~~~~~~~~~~~~

.. method:: bulk_create(objs, batch_size=None)

此方法以有效的方式（通常只有 1 个查询，无论有多少对象）将提供的对象列表插入到数据库中::

    >>> Entry.objects.bulk_create([
    ...     Entry(headline='This is a test'),
    ...     Entry(headline='This is only a test'),
    ... ])

这有一些注意事项：

* 将不会调用模型的 ``save()`` 方法，并且不会发送 ``pre_save`` 和 ``post_save`` 信号。
* 它不适用于多表继承场景中的子模型。
* 如果模型的主键是 :class:`~django.db.models.AutoField` ，它不会像 ``save()`` 那样检索和设置主键属性，除非数据库后端支持（目前只有 PostgreSQL）。
* 它不适用于多对多关系。

.. versionchanged:: 1.9

    添加了代理模型使用 ``bulk_create()`` 的支持。

.. versionchanged:: 1.10

    添加了当使用 PostgreSQL 时使用 ``bulk_create()`` 创建对象时设置主键的支持。

``batch_size`` 参数控制在单个查询中创建的对象数。默认值是在一个批处理中创建所有对象，除了 SQLite，其中默认值为每个查询最多使用 999 个变量。

``count()``
~~~~~~~~~~~

.. method:: count()

返回在数据库中对应的 ``QuerySet`` 对象的个数。``count()`` 永远不会引发异常。

例如::

    # Returns the total number of entries in the database.
    Entry.objects.count()

    # Returns the number of entries whose headline contains 'Lennon'
    Entry.objects.filter(headline__contains='Lennon').count()

``count()`` 在后台执行 ``SELECT COUNT(*)``，所以你应该始终使用 ``count()`` 而不是将所有的记录加载到 Python 对象中并在结果上调用 ``len()``（除非你需要将对象加载到内存中，``len()`` 会更快）。

根据您使用的数据库（例如 PostgreSQL vs. MySQL），``count()`` 可能返回一个长整型而不是普通的 Python 整数。这是一个底层的实现习惯，不应该引起任何真实世界的问题。

请注意，如果您想要 ``QuerySet`` 中的项目数量，并且还要从中检索模型实例（例如，通过迭代它），使用 ``len(queryset)`` ，这不会导致额外的数据库查询，如 ``count()`` 。

``in_bulk()``
~~~~~~~~~~~~~

.. method:: in_bulk(id_list=None)

获取主键值的列表，并返回将每个主键值映射到具有给定 ID 的对象的实例的字典。

Example::

    >>> Blog.objects.in_bulk([1])
    {1: <Blog: Beatles Blog>}
    >>> Blog.objects.in_bulk([1, 2])
    {1: <Blog: Beatles Blog>, 2: <Blog: Cheddar Talk>}
    >>> Blog.objects.in_bulk([])
    {}
    >>> Blog.objects.in_bulk()
    {1: <Blog: Beatles Blog>, 2: <Blog: Cheddar Talk>, 3: <Blog: Django Weblog>}

如果你传递给 ``in_bulk()`` 一个空列表，你会得到一个空的字典。

.. versionchanged:: 1.10

    在旧版本中，``id_list`` 是必填参数。

``iterator()``
~~~~~~~~~~~~~~

.. method:: iterator()

对 ``QuerySet`` 求值（通过执行查询），并返回一个迭代器（参见 :pep:`234`）。``QuerySet`` 通常在内部缓存其结果，以便重复计算不会导致其他查询。相反，``iterator()`` 将直接读取结果，而不在 ``QuerySet`` 级别执行任何缓存（内部，默认迭代器调用 ``iterator()`` 并高速缓存返回值）。对于返回大量只需要访问一次的对象的 ``QuerySet``，这可以带来更好的性能和显着减少内存。

请注意，在已经求值的 ``QuerySet`` 上使用 ``iterator()`` 会强制它再次计算，重复查询。

此外，使用 ``iterator()`` 会导致先前的 ``prefetch_related()`` 调用被忽略，因为这两个优化一起使用没有意义。

.. warning::

    一些 Python 数据库驱动程序如 ``psycopg2`` 如果使用客户端游标（实例化 ``connection.cursor()`` 和 Django 的 ORM 使用）执行缓存。使用 ``iterator()`` 不会影响数据库驱动程序级别的缓存。要禁用此缓存，请查看 `服务器端游标`_.

.. _服务器端游标: http://initd.org/psycopg/docs/usage.html#server-side-cursors

``latest()``
~~~~~~~~~~~~

.. method:: latest(field_name=None)

使用作为日期字段提供的 ``field_name``，按日期返回表中的最新对象。

此示例根据 ``pub_date`` 字段返回表中的最新 ``Entry``::

    Entry.objects.latest('pub_date')

如果模型的 :ref:`Meta <meta-options>` 指定 :attr:`~django.db.models.Options.get_latest_by`，则可以将 ``field_name`` 参数留给 ``earliest()`` 或者 ``latest()``。默认情况下，Django 将使用 :attr:`~django.db.models.Options.get_latest_by` 中指定的字段。

像 :meth:`get()`，``earliest()`` 和 ``latest()``，如果给定的参数找不到对象将抛出 :exc:`~django.db.models.Model.DoesNotExist`。

请注意，``earliest()`` 和 ``latest()`` 仅仅是为了方便和可读性。

.. admonition:: ``earliest()`` 和 ``latest()`` 可能会返回没有日期的实例。

    由于将排序委派给数据库，因此如果使用不同的数据库，则允许空值的字段的结果可能会有不同的排序。例如，PostgreSQL 和 MySQL 空值排序高于非空值，而 SQLite 则相反。

    您可能想要过滤掉空值::

        Entry.objects.filter(pub_date__isnull=False).latest('pub_date')

``earliest()``
~~~~~~~~~~~~~~

.. method:: earliest(field_name=None)

除非方向更改，否则像 :meth:`~django.db.models.query.QuerySet.latest`。

``first()``
~~~~~~~~~~~

.. method:: first()

返回结果集的第一个对象, 当没有找到时返回 ``None``。如果 ``QuerySet`` 没有设置排序，则将会自动按主键进行排序。

例如::

    p = Article.objects.order_by('title', 'pub_date').first()

注意，``first()`` 是一个简便方法，下面这个例子和上面的代码效果是一样::

    try:
        p = Article.objects.order_by('title', 'pub_date')[0]
    except IndexError:
        p = None

``last()``
~~~~~~~~~~

.. method:: last()

工作方式类似  :meth:`first()`，只是返回的是查询集中最后一个对象。

``aggregate()``
~~~~~~~~~~~~~~~

.. method:: aggregate(*args, **kwargs)

返回一个字典，包含根据 ``QuerySet`` 计算得到的聚合值（平均数、和等等）。``aggregate()`` 的每个参数指定返回的字典中将要包含的值。

Django 提供的聚合函数在下文的 `聚合函数`_ 中讲述。由于聚合也是 :doc:`查询表达式 </ref/models/expressions>`，你可以组合多个聚合以及值来创建复杂的聚合。

使用关键字参数指定的聚合将使用关键字参数的名称作为注解的名称。匿名的参数的名称将基于聚合函数的名称和模型字段生成。复杂的聚合不可以使用匿名参数，它们必须指定一个关键字参数作为别名。

例如，当你使用 ``Blog Entry`` 时，你可能想知道对 ``Author`` 贡献的 ``Blog Entry`` 的数目：::

    >>> from django.db.models import Count
    >>> q = Blog.objects.aggregate(Count('entry'))
    {'entry__count': 16}

通过使用关键字参数来指定聚合函数，你可以控制返回的聚合的值的名称::

    >>> q = Blog.objects.aggregate(number_of_entries=Count('entry'))
    {'number_of_entries': 16}

聚合的深入讨论，参见 :doc:`聚合的指南 </topics/db/aggregation>`。

``exists()``
~~~~~~~~~~~~

.. method:: exists()

如果 :class:`.QuerySet` 包含任何结果，则返回 ``True``，否则返回 ``False``。它会试图用最简单和最快的方法完成查询，但它执行的方法与普通的 :class:`.QuerySet` 查询 *确实* 几乎相同。

:meth:`~.QuerySet.exists` 对于在 :class:`.QuerySet` 中搜索对象成员关系和确认在 :class:`.QuerySet` 中存在任何对象很有用，特别是 :class:`.QuerySet` 的上下文比较大的时候。

查找具有唯一性字段（例如 ``primary_key``）的模型是否在一个 :class:`.QuerySet` 中的最高效的方法是::

    entry = Entry.objects.get(pk=123)
    if some_queryset.filter(pk=entry.pk).exists():
        print("Entry contained in queryset")

它将比下面的这种要求对整个查询集求值并迭代的方法快很多::

    if entry in some_queryset:
       print("Entry contained in QuerySet")

若要查找一个查询集是否包含任何元素::

    if some_queryset.exists():
        print("There is at least one object in some_queryset")

将快于::

    if some_queryset:
        print("There is at least one object in some_queryset")

... 但不会快很多（因为这需要很大的查询集以获得效率的提升）。

另外，如果 ``some_queryset`` 还没有求值，但你知道它将在某个时刻求值，那么使用 ``some_queryset.exists()`` 将比简单地使用 ``bool(some_queryset)`` 完成更多的工作（一个查询用于存在性检查，另外一个是后面的求值），后者将求值并检查是否有结果返回。

``update()``
~~~~~~~~~~~~

.. method:: update(**kwargs)

对指定的字段执行 SQL 更新查询，并返回匹配的行数（如果某些行已具有新值，则可能不等于已更新的行数）。

例如，要对 2010 年发布的所有博客条目启用评论，您可以执行以下操作::

    >>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False)

（假设您的 ``Entry`` 模型具有 ``pub_date`` 和 ``comments_on`` 字段。）

您可以更新多个字段 —— 没有多少字段的限制。例如，在这里我们更新 ``comments_on`` 和 ``headline`` 字段::

    >>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old')

``update()`` 方法立即应用，对更新的 :class:`.QuerySet` 的唯一限制是它只能更新模型主表中的列，而不是相关模型。例如你不能这样做::

    >>> Entry.objects.update(blog__name='foo') # Won't work!

仍然可以根据相关字段进行过滤::

    >>> Entry.objects.filter(blog__id=1).update(comments_on=True)

您不能在 :class:`.QuerySet` 上调用 ``update()``，该查询已截取一个切片，或者无法再进行过滤。

``update()`` 方法返回受影响的行数::

    >>> Entry.objects.filter(id=64).update(comments_on=True)
    1

    >>> Entry.objects.filter(slug='nonexistent-slug').update(comments_on=True)
    0

    >>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False)
    132

如果你只是更新一个记录，不需要对模型对象做任何事情，最有效的方法是调用 ``update()``，而不是将模型对象加载到内存中。例如，不这样做::

    e = Entry.objects.get(id=10)
    e.comments_on = False
    e.save()

...而这样做::

    Entry.objects.filter(id=10).update(comments_on=False)

使用 ``update()`` 还可以防止在加载对象和调用 ``save()`` 之间的短时间内数据库中某些内容可能发生更改的紊乱情况。

最后，意识到 ``update()`` 是在 SQL 级别执行更新，因此不会在模型上调用任何 ``save()`` 方法，也不会发出 :attr:`~django.db.models.signals.pre_save` 或 :attr:`~django.db.models.signals.post_save` 信号（这是调用 :meth:`Model.save() <django.db.models.Model.save>` 的结果）。如果你想为一个有自定义 :meth:`~django.db.models.Model.save()` 方法的模型更新一连串记录，循环遍历它们并调用 :meth:`~django.db.models.Model.save()`，像这样::

    for e in Entry.objects.filter(pub_date__year=2010):
        e.comments_on = False
        e.save()

``delete()``
~~~~~~~~~~~~

.. method:: delete()

对 :class:`.QuerySet` 中的所有行执行 SQL 删除查询，并返回删除的对象数以及每种类型对象的删除数量的字典。

``delete()`` 是即时执行的。您不能在已被切片或其他方式过滤后的 :class:`.QuerySet` 上调用 ``delete()``。

例如，要删除特定博客中的所有条目::

    >>> b = Blog.objects.get(pk=1)

    # Delete all the entries belonging to this Blog.
    >>> Entry.objects.filter(blog=b).delete()
    (4, {'weblog.Entry': 2, 'weblog.Entry_authors': 2})

.. versionchanged:: 1.9

    添加了被删除对象数的返回值描述。

默认情况下，Django 的 :class:`~django.db.models.ForeignKey` 模拟 SQL 约束 ``ON DELETE CASCADE`` —— 换一种说法，任何具有指向要删除的对象的外键的对象将与它们一起被删除。例如::

    >>> blogs = Blog.objects.all()

    # This will delete all Blogs and all of their Entry objects.
    >>> blogs.delete()
    (5, {'weblog.Blog': 1, 'weblog.Entry': 2, 'weblog.Entry_authors': 2})

此级联行为可通过 :attr:`~django.db.models.ForeignKey.on_delete` 的 :class:`~django.db.models.ForeignKey` 参数自定义。

``delete()`` 方法执行批量删除，并且不会在模型上调用任何 ``delete()`` 方法。但它会为所有已删除的对象（包括级联删除）发出 :data:`~django.db.models.signals.pre_delete` 和 :data:`~django.db.models.signals.post_delete` 信号。

Django 需要获取对象到内存中以发送信号和处理级联。然而，如果没有级联和没有信号，那么 Django 可以采取快速路径并删除对象而不提取到内存中。对于大型删除，这可以显着减少内存使用。执行的查询量也可以减少。

:attr:`~django.db.models.ForeignKey.on_delete` 设置为 ``DO_NOTHING`` 的外键不会阻止在删除时采用快速路径。

请注意，在对象删除中生成的查询的实现细节可能会更改。

``as_manager()``
~~~~~~~~~~~~~~~~

.. classmethod:: as_manager()

类方法，返回 :class:`~django.db.models.Manager` 的实例与 ``QuerySet`` 的方法的副本。有关详细信息，请参见 :ref:`create-manager-with-queryset-methods`。

.. _field-lookups:

``Field`` 查找
-----------------

字段查找是指如何指定 SQL ``WHERE`` 子句的内容，它们通过 ``QuerySet`` 的 :meth:`filter()`，:meth:`exclude()` 和 :meth:`get()` 方法的关键字参数指定。

简单介绍请参考 :ref:`模型与数据库查询文档 <field-lookups-intro>`。

以下列出了 Django 的内置查找。也可以为模型字段编写 :doc:`自定义查找 </howto/custom-lookups>`。

为了方便，当没有提供查找类型时（例如 ``Entry.objects.get(id=14)``），查找类型假定为 :lookup:`exact`。

.. fieldlookup:: exact

``exact``
~~~~~~~~~

精确匹配。如果为比较提供的值为 ``None``，它将被解释为 SQL ``NULL`` （有关详细信息，请参阅 :lookup:`isnull`）。

例如::

    Entry.objects.get(id__exact=14)
    Entry.objects.get(id__exact=None)

等效 SQL::

    SELECT ... WHERE id = 14;
    SELECT ... WHERE id IS NULL;

.. admonition:: MySQL 比较

    在 MySQL 中，数据库表的“排序规则”设置确定 ``exact`` 比较是否区分大小写。这是一个数据库设置，而 *不是* 一个 Django 设置。可以配置 MySQL 表以使用区分大小写的比较，但涉及一些权衡。有关详细信息，请参阅 :doc:`数据库 </ref/databases>` 文档中的 :ref:`排序设置部分 <mysql-collation>`。

.. fieldlookup:: iexact

``iexact``
~~~~~~~~~~

不区分大小写的精确匹配。如果为比较提供的值为 ``None``，它将被解释为 SQL ``NULL`` （详细信息请参阅 :lookup:`isnull`）。

例如::

    Blog.objects.get(name__iexact='beatles blog')
    Blog.objects.get(name__iexact=None)

等效 SQL::

    SELECT ... WHERE name ILIKE 'beatles blog';
    SELECT ... WHERE name IS NULL;

请注意，第一个查询将匹配 ``'Beatles Blog'``，``'beatles blog'``，``'BeAtLes BLoG'`` 等。

.. admonition:: SQLite 用户

    当使用 SQLite 后端和 Unicode（非ASCII）字符串时，请记住关于字符串比较的 :ref:`数据库注解 <sqlite-string-matching>`。SQLite 不对 Unicode 字符串进行不区分大小写的匹配。

.. fieldlookup:: contains

``contains``
~~~~~~~~~~~~

区分大小写的模糊匹配。

例如::

    Entry.objects.get(headline__contains='Lennon')

等效 SQL::

    SELECT ... WHERE headline LIKE '%Lennon%';

请注意，这将匹配标题 ``'Lennon honored today'`` 但不匹配 ``'lennon honored today'``。

.. admonition:: SQLite 用户

    SQLite 不支持区分大小写的 ``LIKE`` 语句；用于 SQLite 的 ``contains`` 和 ``icontains`` 一样。更多信息请参阅 :ref:`数据库注解 <sqlite-string-matching>`。


.. fieldlookup:: icontains

``icontains``
~~~~~~~~~~~~~

不区分大小写的模糊匹配。

例如::

    Entry.objects.get(headline__icontains='Lennon')

等效 SQL::

    SELECT ... WHERE headline ILIKE '%Lennon%';

.. admonition:: SQLite 用户

    当使用 SQLite 后端和 Unicode（非ASCII）字符串时，请铭记关于字符串比较的 :ref:`数据库注解 <sqlite-string-matching>`。

.. fieldlookup:: in

``in``
~~~~~~

在给定的列表。

例如::

    Entry.objects.filter(id__in=[1, 3, 4])

等效 SQL::

    SELECT ... WHERE id IN (1, 3, 4);

您还可以使用查询集对列表动态求值，而不是提供字面值列表::

    inner_qs = Blog.objects.filter(name__contains='Cheddar')
    entries = Entry.objects.filter(blog__in=inner_qs)

此查询集将作为子 SELECT 语句求值::

    SELECT ... WHERE blog.id IN (SELECT id FROM ... WHERE NAME LIKE '%Cheddar%')

如果你通过 ``values()`` 或 ``values_list()`` 传入 ``QuerySet`` 作为 ``__in`` 查找的值，您需要确保您只提取结果中的一个字段。例如，这将工作（过滤博客名称）::

    inner_qs = Blog.objects.filter(name__contains='Ch').values('name')
    entries = Entry.objects.filter(blog__name__in=inner_qs)

这个例子将产生一个异常，由于内查询试图提取两个字段的值，但是查询语句只期望提取一个字段的值::

    # Bad code! Will raise a TypeError.
    inner_qs = Blog.objects.filter(name__contains='Ch').values('name', 'id')
    entries = Entry.objects.filter(blog__name__in=inner_qs)

.. _nested-queries-performance:

.. admonition:: 性能注意事项

    对于使用嵌套查询并了解你的数据库服务器的性能特性（如果有疑问，去做基准测试）要谨慎。一些数据库后端，最着名的是 MySQL，不能很好地优化嵌套查询。在这些情况下，提取值列表然后将其传递到第二个查询中更有效。也就是说，执行两个查询，而不是一个::

        values = Blog.objects.filter(
                name__contains='Cheddar').values_list('pk', flat=True)
        entries = Entry.objects.filter(blog__in=list(values))

    请注意 ``list()`` 调用 ``Blog`` ``QuerySet`` 以强制执行第一个查询。没有它，将执行嵌套查询，因为 :ref:`querysets-are-lazy`。

.. fieldlookup:: gt

``gt``
~~~~~~

大于。

例如::

    Entry.objects.filter(id__gt=4)

等效 SQL::

    SELECT ... WHERE id > 4;

.. fieldlookup:: gte

``gte``
~~~~~~~

大于等于。

.. fieldlookup:: lt

``lt``
~~~~~~

小于。

.. fieldlookup:: lte

``lte``
~~~~~~~

小于等于。

.. fieldlookup:: startswith

``startswith``
~~~~~~~~~~~~~~

区分大小写的开始于。

例如::

    Entry.objects.filter(headline__startswith='Will')

等效 SQL::

    SELECT ... WHERE headline LIKE 'Will%';

SQLite 不支持区分大小写的 ``LIKE`` 语句；SQLite 的 ``startswith`` 和 ``istartswith`` 一样。

.. fieldlookup:: istartswith

``istartswith``
~~~~~~~~~~~~~~~

不区分大小写的开始于。

例如::

    Entry.objects.filter(headline__istartswith='will')

等效 SQL::

    SELECT ... WHERE headline ILIKE 'Will%';

.. admonition:: SQLite 用户

    当使用 SQLite 后端和 Unicode（非ASCII）字符串时，请铭记关于字符串比较的 :ref:`数据库注解 <sqlite-string-matching>`。

.. fieldlookup:: endswith

``endswith``
~~~~~~~~~~~~

区分大小写的结束于。

例如::

    Entry.objects.filter(headline__endswith='cats')

等效 SQL::

    SELECT ... WHERE headline LIKE '%cats';

.. admonition:: SQLite 用户

    SQLite 不支持区分大小写的 ``LIKE`` 语句；SQLite 的 ``endswith`` 和 ``iendswith`` 一样。更多信息请参阅 :ref:`数据库注解 <sqlite-string-matching>` 文档。

.. fieldlookup:: iendswith

``iendswith``
~~~~~~~~~~~~~

不区分大小写的结束于。

例如::

    Entry.objects.filter(headline__iendswith='will')

等效 SQL::

    SELECT ... WHERE headline ILIKE '%will'

.. admonition:: SQLite 用户

    当使用 SQLite 后端和 Unicode（非ASCII）字符串时，请铭记关于字符串比较的 :ref:`数据库注解 <sqlite-string-matching>`。

.. fieldlookup:: range

``range``
~~~~~~~~~

范围匹配（包含于之中）。

例如::

    import datetime
    start_date = datetime.date(2005, 1, 1)
    end_date = datetime.date(2005, 3, 31)
    Entry.objects.filter(pub_date__range=(start_date, end_date))

等效 SQL::

    SELECT ... WHERE pub_date BETWEEN '2005-01-01' and '2005-03-31';

您可以在任何可以使用 ``BETWEEN`` 的 SQL 中使用 ``range`` —— 日期，数字和偶数字符。

.. warning::

    过滤具有日期的 ``DateTimeField`` 不会包含最后一天的项目，因为边界被解释为“给定日期的凌晨”。如果 ``pub_date`` 是 ``DateTimeField``，上面的表达式将变成这个 SQL::

        SELECT ... WHERE pub_date BETWEEN '2005-01-01 00:00:00' and '2005-03-31 00:00:00';

    一般来说，不能混合使用 ``Date`` 和 ``DateTime``。

.. fieldlookup:: date

``date``
~~~~~~~~

.. versionadded:: 1.9

面向 ``DateTime`` 字段，将值转换为日期。允许链接额外的字段查找。接受一个日期值。

例如::

    Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))
    Entry.objects.filter(pub_date__date__gt=datetime.date(2005, 1, 1))

（此查找不包括等效的 SQL 代码片段，因为相关查询的实现因不同数据库引擎而异。）

当 :setting:`USE_TZ` 为 ``True`` 时，在过滤之前，字段将被转换为当前时区。

.. fieldlookup:: year

``year``
~~~~~~~~

面向 ``Date`` 和 ``DateTime`` 字段，匹配确切的年份。允许链接额外的字段查找。接受一个整数年。

例如::

    Entry.objects.filter(pub_date__year=2005)
    Entry.objects.filter(pub_date__year__gte=2005)

等效 SQL::

    SELECT ... WHERE pub_date BETWEEN '2005-01-01' AND '2005-12-31';
    SELECT ... WHERE pub_date >= '2005-01-01';

（确切的 SQL 语法因每个数据库引擎而异。）

当 :setting:`USE_TZ` 为 ``True`` 时，在过滤之前，``DateTime`` 字段将被转换为当前时区。


.. versionchanged:: 1.9

    允许链接额外的字段查找。

.. fieldlookup:: month

``month``
~~~~~~~~~

面向 ``Date`` 和 ``DateTime`` 字段，匹配确切的月份。允许链接额外的字段查找。接受一个从 1（一月） 到 12（十二月）的整数。

例如::

    Entry.objects.filter(pub_date__month=12)
    Entry.objects.filter(pub_date__month__gte=6)

等效 SQL::

    SELECT ... WHERE EXTRACT('month' FROM pub_date) = '12';
    SELECT ... WHERE EXTRACT('month' FROM pub_date) >= '6';

（确切的 SQL 语法因每个数据库引擎而异。）

当 :setting:`USE_TZ` 为 ``True`` 时，在过滤之前，``DateTime`` 字段将被转换为当前时区。这需要 :ref:`在数据库中定义时区 <database-time-zone-definitions>`。

.. versionchanged:: 1.9

    允许链接额外的字段查找。

.. fieldlookup:: day

``day``
~~~~~~~

面向 ``Date`` 和 ``DateTime`` 字段，具体到某一天的匹配。允许链接额外的字段查找。接受一个整数的天数。

例如::

    Entry.objects.filter(pub_date__day=3)
    Entry.objects.filter(pub_date__day__gte=3)

等效 SQL::

    SELECT ... WHERE EXTRACT('day' FROM pub_date) = '3';
    SELECT ... WHERE EXTRACT('day' FROM pub_date) >= '3';

（确切的 SQL 语法因每个数据库引擎而异。）

请注意，这将匹配到任何 pub_date 在每月第三天（例如1月3日，7月3日等）的记录。

当 :setting:`USE_TZ` 为 ``True`` 时，在过滤之前，``DateTime`` 字段将被转换为当前时区。这需要 :ref:`在数据库中定义时区 <database-time-zone-definitions>`。

.. versionchanged:: 1.9

    允许链接额外的字段查找。

.. fieldlookup:: week_day

``week_day``
~~~~~~~~~~~~

面向 ``Date`` 和 ``DateTime`` 字段，匹配‘一周的第几天’。允许链接额外的字段查找。

接受一个从 1（星期日） 到 7（星期六） 的整数表示一周的第几天。

例如::

    Entry.objects.filter(pub_date__week_day=2)
    Entry.objects.filter(pub_date__week_day__gte=2)

（此查找不包括等效的 SQL 代码片段，因为相关查询的实现因不同数据库引擎而异。）

请注意，这将匹配 ``pub_date`` 在星期一（一周的第 2 天）的任何记录，而不管其出现的月份或年份。周中的每天被索引为第 1 天为星期日，第 7 天为星期六。

当 :setting:`USE_TZ` 为 ``True`` 时，在过滤之前，``DateTime`` 字段将被转换为当前时区。这需要 :ref:`在数据库中定义时区 <database-time-zone-definitions>`。

.. versionchanged:: 1.9

    允许链接额外的字段查找。

.. fieldlookup:: hour

``hour``
~~~~~~~~

面向 ``DateTime`` 和 ``Time`` 字段，匹配确切的小时。允许链接额外的字段查找。接受一个从 0 到 23 的整数。

例如::

    Event.objects.filter(timestamp__hour=23)
    Event.objects.filter(time__hour=5)
    Event.objects.filter(timestamp__hour__gte=12)

等效 SQL::

    SELECT ... WHERE EXTRACT('hour' FROM timestamp) = '23';
    SELECT ... WHERE EXTRACT('hour' FROM time) = '5';
    SELECT ... WHERE EXTRACT('hour' FROM timestamp) >= '12';

（确切的 SQL 语法因每个数据库引擎而异。）

对于 ``DateTime`` 字段，当 :setting:`USE_TZ` 为 ``True`` 时，在过滤之前，值将被转换为当前时区。

.. versionchanged:: 1.9

    添加了 :class:`~django.db.models.TimeField` 的 SQLite 支持（其他数据库在 1.7 已经被支持）。

.. versionchanged:: 1.9

    允许链接额外的字段查找。

.. fieldlookup:: minute

``minute``
~~~~~~~~~~

面向 ``DateTime`` 和 ``Time`` 字段，匹配确切的分钟。允许链接额外的字段查找。接受一个从 0 到 59 的整数。

例如::

    Event.objects.filter(timestamp__minute=29)
    Event.objects.filter(time__minute=46)
    Event.objects.filter(timestamp__minute__gte=29)

等效 SQL::

    SELECT ... WHERE EXTRACT('minute' FROM timestamp) = '29';
    SELECT ... WHERE EXTRACT('minute' FROM time) = '46';
    SELECT ... WHERE EXTRACT('minute' FROM timestamp) >= '29';

（确切的 SQL 语法因每个数据库引擎而异。）

对于 ``DateTime`` 字段，当 :setting:`USE_TZ` 为 ``True`` 时，在过滤之前，值将被转换为当前时区。

.. versionchanged:: 1.9

    添加了 :class:`~django.db.models.TimeField` 的 SQLite 支持（其他数据库在 1.7 已经被支持）。

.. versionchanged:: 1.9

    允许链接额外的字段查找。

.. fieldlookup:: second

``second``
~~~~~~~~~~

面向 ``DateTime`` 和 ``Time`` 字段，匹配确切的秒数。允许链接额外的字段查找。接受一个从 0 到 59 的整数。

例如::

    Event.objects.filter(timestamp__second=31)
    Event.objects.filter(time__second=2)
    Event.objects.filter(timestamp__second__gte=31)

等效 SQL::

    SELECT ... WHERE EXTRACT('second' FROM timestamp) = '31';
    SELECT ... WHERE EXTRACT('second' FROM time) = '2';
    SELECT ... WHERE EXTRACT('second' FROM timestamp) >= '31';

（确切的 SQL 语法因每个数据库引擎而异。）

对于 ``DateTime`` 字段，当 :setting:`USE_TZ` 为 ``True`` 时，在过滤之前，值将被转换为当前时区。

.. versionchanged:: 1.9

    添加了 :class:`~django.db.models.TimeField` 的 SQLite 支持（其他数据库在 1.7 已经被支持）。

.. versionchanged:: 1.9

    允许链接额外的字段查找。

.. fieldlookup:: isnull

``isnull``
~~~~~~~~~~

接受 ``True`` 或 ``False``，分别相当于 SQL 语句 ``IS NULL`` 和 ``IS NOT NULL``。

例如::

    Entry.objects.filter(pub_date__isnull=True)

等效 SQL::

    SELECT ... WHERE pub_date IS NULL;

.. fieldlookup:: search

``search``
~~~~~~~~~~

.. deprecated:: 1.10

    如何替换请参见 :ref:`1.10 发行说明 <search-lookup-replacement>`。

一个布尔类型的全文搜索，利用全文索引。这个很像 :lookup:`contains`，但是由于全文索引的优势使它显著的快。

例如::

    Entry.objects.filter(headline__search="+Django -jazz Python")

等效 SQL::

    SELECT ... WHERE MATCH(tablename, headline) AGAINST (+Django -jazz Python IN BOOLEAN MODE);

注意，这仅在 MySQL 中可用，并且需要直接操作数据库以添加全文索引。默认情况下，Django 使用 BOOLEAN MODE 进行全文搜索。有关其他详细信息，请参阅 `MySQL 文档`_。

.. _MySQL 文档: https://dev.mysql.com/doc/refman/en/fulltext-boolean.html

.. fieldlookup:: regex

``regex``
~~~~~~~~~

区分大小写的正则表达式匹配。

正则表达式语法是正在使用的数据库后端的语法。在 SQLite 没有内置正则表达式支持的情况下，此功能由（Python）用户定义的 REGEXP 函数提供，因此正则表达式语法是 Python 的 ``re`` 模块。

例如::

    Entry.objects.get(title__regex=r'^(An?|The) +')

等效 SQL::

    SELECT ... WHERE title REGEXP BINARY '^(An?|The) +'; -- MySQL

    SELECT ... WHERE REGEXP_LIKE(title, '^(An?|The) +', 'c'); -- Oracle

    SELECT ... WHERE title ~ '^(An?|The) +'; -- PostgreSQL

    SELECT ... WHERE title REGEXP '^(An?|The) +'; -- SQLite

建议使用原始字符串（例如，``r'foo'`` 而不是 ``'foo'``）来传递正则表达式语法。

.. fieldlookup:: iregex

``iregex``
~~~~~~~~~~

不区分大小写的正则表达式匹配。

例如::

    Entry.objects.get(title__iregex=r'^(an?|the) +')

等效 SQL::

    SELECT ... WHERE title REGEXP '^(an?|the) +'; -- MySQL

    SELECT ... WHERE REGEXP_LIKE(title, '^(an?|the) +', 'i'); -- Oracle

    SELECT ... WHERE title ~* '^(an?|the) +'; -- PostgreSQL

    SELECT ... WHERE title REGEXP '(?i)^(an?|the) +'; -- SQLite

.. _aggregation-functions:

聚合函数
---------------------

.. currentmodule:: django.db.models

Django 的 ``django.db.models`` 模块提供以下聚合函数。关于如何使用这些聚合函数的细节，参见 :doc:`聚合函数指南 </topics/db/aggregation>`。阅读 :class:`~django.db.models.Aggregate` 文档学习如何创建聚合函数。

.. warning::

    SQLite 不能直接处理日期/时间字段的聚合。这是因为 SQLite 中没有原生的日期/时间字段，Django 目前使用文本字段模拟它的功能。在 SQLite 中对日期/时间字段使用聚合将引发 ``NotImplementedError``。

.. admonition:: Note

    在 ``QuerySet`` 为空时，聚合函数函数将返回 ``None``。例如，如果 ``QuerySet`` 中没有记录，``Sum`` 聚合函数将返回 ``None`` 而不是 ``0``。``Count`` 是一个例外，如果 ``QuerySet`` 为空，它将返回 ``0``。

所有聚合函数具有以下共同的参数：

``expression``
~~~~~~~~~~~~~~

一个引用模型上字段的字符串，或者一个 :doc:`查询表达式 </ref/models/expressions>`。

``output_field``
~~~~~~~~~~~~~~~~

用来表示返回值的 :doc:`模型字段 </ref/models/fields>`，它是一个可选的参数。

.. note::

    在组合多个类型的字段时，只有在所有的字段都是相同类型的情况下，Django 才能确定 ``output_field``。否则，你必须自己提供 ``output_field`` 参数。

``**extra``
~~~~~~~~~~~

这些关键字参数可以给聚合函数生成的 SQL 提供额外的信息。

``Avg``
~~~~~~~

.. class:: Avg(expression, output_field=FloatField(), **extra)

    返回给定表达式的平均值，除非你指定了不同的 ``output_field``，其一定是数值。

    * 默认别名：``<field>__avg``
    * 返回类型：``float``（或指定的 ``output_field`` 的类型）

    .. versionchanged:: 1.9

        添加了 ``output_field`` 参数以允许聚合非数字列，例如 ``DurationField``。

``Count``
~~~~~~~~~

.. class:: Count(expression, distinct=False, **extra)

    返回与表达式相关的对象的个数。

    * 默认别名：``<field>__count``
    * 返回类型：``int``

    有一个可选的参数：

    .. attribute:: distinct

        如果 ``distinct=True``，Count 将只计算唯一的实例。它等同于 ``COUNT(DISTINCT <field>)`` SQL 语句。默认值为 ``False``。

``Max``
~~~~~~~

.. class:: Max(expression, output_field=None, **extra)

    返回给定表达式的最大值。

    * 默认别名：``<field>__max``
    * 返回类型：与输入字段的类型相同，或者 ``output_field`` 提供的类型

``Min``
~~~~~~~

.. class:: Min(expression, output_field=None, **extra)

    返回给定表达式的最小值。

    * 默认别名：``<field>__min``
    * 返回类型：与输入字段的类型相同，或者 ``output_field`` 提供的类型

``StdDev``
~~~~~~~~~~

.. class:: StdDev(expression, sample=False, **extra)

    返回给定表达式的数据的标准差。

    * 默认别名：``<field>__stddev``
    * 返回类型：``float``

    有一个可选的参数：

    .. attribute:: sample

        默认情况下，``StdDev`` 返回群体的标准差。但是，如果 ``sample=True``，返回的值将是样本的标准差。

    .. admonition:: SQLite

        SQLite 没有直接提供 ``StdDev``。有一个可用的实现是 SQLite 的一个扩展模块。参见 `SQlite 文档`_ 中获取并安装这个扩展的指南。

``Sum``
~~~~~~~

.. class:: Sum(expression, output_field=None, **extra)

    计算给定表达式的所有值的和。

    * 默认别名：``<field>__sum``
    * 返回类型：与输入字段的类型相同，或者 ``output_field`` 提供的类型

``Variance``
~~~~~~~~~~~~

.. class:: Variance(expression, sample=False, **extra)

    返回给定表达式的数据的方差。

    * 默认别名：``<field>__variance``
    * 返回类型：``float``

    有一个可选的参数：

    .. attribute:: sample

        默认情况下，``Variance`` 返回群体的方差。但是，如果 ``sample=True``，返回的值将是样本的方差。

    .. admonition:: SQLite

        SQLite 没有直接提供 ``Variance``。有一个可用的实现是 SQLite 的一个扩展模块。 参见 `SQlite 文档`_ 中获取并安装这个扩展的指南。

.. _SQLite 文档: https://www.sqlite.org/contrib

查询相关工具
===================

本节提供查询相关的工具的参考资料，它们其它地方没有文档。

``Q()`` 对象
---------------

.. class:: Q

``Q()`` 对象和 :class:`~django.db.models.F` 对象类似，把一个 SQL 表达式封装在 Python 对象中，这个对象可以用于数据库相关的操作。

通常，``Q() 对象`` 使得定义查询条件然后重用成为可能。这允许 :ref:`构建复杂数据库查询 <complex-lookups-with-q>` 使用 ``|`` (``OR``) 和 ``&`` (``AND``) 操作符; 否则 ``QuerySets`` 中使用不了 ``OR``。

``Prefetch()`` 对象
----------------------

.. class:: Prefetch(lookup, queryset=None, to_attr=None)

``Prefetch()`` 对象可用于控制 :meth:`~django.db.models.query.QuerySet.prefetch_related()` 的操作。

``lookup`` 参数描述了跟随的关系，并且工作方式与传递给 :meth:`~django.db.models.query.QuerySet.prefetch_related()` 的基于字符串的查找相同。例如：

    >>> from django.db.models import Prefetch
    >>> Question.objects.prefetch_related(Prefetch('choice_set')).get().choice_set.all()
    <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>
    # This will only execute two queries regardless of the number of Question
    # and Choice objects.
    >>> Question.objects.prefetch_related(Prefetch('choice_set')).all()
    <QuerySet [<Question: Question object>]>

``queryset`` 参数为给定的查找提供基础 ``QuerySet``。这对于进一步过滤预取操作或从预取关系调用 :meth:`~django.db.models.query.QuerySet.select_related()` 很有用，由此进一步减少查询数量：

    >>> voted_choices = Choice.objects.filter(votes__gt=0)
    >>> voted_choices
    <QuerySet [<Choice: The sky>]>
    >>> prefetch = Prefetch('choice_set', queryset=voted_choices)
    >>> Question.objects.prefetch_related(prefetch).get().choice_set.all()
    <QuerySet [<Choice: The sky>]>

``to_attr`` 参数将预取操作的结果设置为自定义属性：

    >>> prefetch = Prefetch('choice_set', queryset=voted_choices, to_attr='voted_choices')
    >>> Question.objects.prefetch_related(prefetch).get().voted_choices
    <QuerySet [<Choice: The sky>]>
    >>> Question.objects.prefetch_related(prefetch).get().choice_set.all()
    <QuerySet [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]>

.. note::

    当使用 ``to_attr`` 时，预取的结果存储在列表中。这可以提供比存储在 ``QuerySet`` 实例内的缓存结果的传统 ``prefetch_related`` 调用显着的速度改进。

``prefetch_related_objects()``
------------------------------

.. function:: prefetch_related_objects(model_instances, *related_lookups)

.. versionadded:: 1.10

在一个可迭代的模型实例上预取给定的查找。 这在接收模型实例的列表而不是 ``QuerySet`` 的代码中很有用；例如，当从缓存获取模型或手动实例化它们时。

传递你要预取的可迭代的模型实例（必须全部是相同的类）和查找，或者 :class:`Prefetch` 对象。举个例子::

    >>> from django.db.models import prefetch_related_objects
    >>> restaurants = fetch_top_restaurants_from_cache()  # A list of Restaurants
    >>> prefetch_related_objects(restaurants, 'pizzas__toppings')
